<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Home Automation Client</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <link rel="stylesheet" href="css/bootstrap.min.css" />
    <link rel="stylesheet" href="css/icons.css" />
    <link rel="stylesheet" href="css/style.css" />
</head>
<body id="mainBody" oncontextmenu="return false;" draggable="false" ondragstart="return false;" ondrop="return false;">
    <div id="iconToolbox" class="toolbox">
        <h4 onclick="toggleToolbox('iconToolbox', 'close')">Icons<button type="button" class="close">&times;&nbsp;&nbsp;</button></h4>
        <form class="form-inline" role="form" onsubmit="loadIcons(); return false;">
            <div class="form-group">
                <div class="col-md-11 input-group toolboxControls">
                    <input type="text" id="iconSearchTxt" class="form-control input-sm" placeholder="search" />
                    <button type="submit" class="input-group-addon pointer"><i class="icon-search"></i></button>
                </div>
            </div>
        </form>
        <div id="iconToolboxScroll" class="toolboxContents" onclick="iconSel(event)"></div>
    </div>
    <div id="widgetToolbox" class="toolbox" align="center">
        <h4 onclick="toggleToolbox('widgetToolbox', 'close')">Widgets<button type="button" class="close">&times;&nbsp;&nbsp;</button></h4>
        <form class="form-inline" role="form" onsubmit="filterWidgets(); return false;">
            <div class="form-group">
                <div class="col-md-11 input-group toolboxControls">
                    <input type="text" id="widgetSearchTxt" class="form-control input-sm" placeholder="search" />
                    <button type="submit" class="input-group-addon pointer"><i class="icon-search"></i></button>
                </div>
           </div>
        </form>
        <div id="widgetToolboxScroll" class="toolboxContents" onclick="iconSel(event)"></div>
    </div>
    <div id="channelToolbox" class="toolbox">
        <h4 onclick="toggleToolbox('channelToolbox', 'close')">Channels<button type="button" class="close">&times;&nbsp;&nbsp;</button></h4>
        <form class="form-inline" role="form" onsubmit="filterChannels(); return false;">
            <div class="form-group">
                <div class="col-md-11 input-group toolboxControls">
                    <input type="text" id="channelSearchTxt" class="form-control input-sm" placeholder="search" />
                    <button type="submit" class="input-group-addon pointer"><i class="icon-search"></i></button>
                </div>
            </div>
        </form><br/>
        <div class="col-lg-11 input-group toolboxControls">
            <button type="button" id="noChannel" onclick="channelSel(event)" class="btn btn-default btn-block">None</button><br />
        </div>
        <div id="channelToolboxScroll" class="toolboxContents" style="top: 135px" onclick="channelSel(event)"></div>
    </div>
    <div class="sidebar" id="sidebar">
        <div class="tabs-left">
            <h4>&nbsp;&nbsp;&nbsp;Screens</h4>
            <h6>&nbsp;</h6>
            <ul id="sidebarList" class="nav nav-tabs"></ul>
            <div id="sideScreenEditor" style="display: none; position: absolute; bottom: 2px; left: 15px;">
                <p class="nav-header">Design Options</p>
                <a class="tip icon nounderline pointer" data-original-title="Add" data-placement="top" onclick="newScreen()"><i class="icon-new-tab icon-large">&nbsp;</i></a>
                <a class="tip icon nounderline pointer" data-original-title="Delete" data-placement="top" onclick="deleteScreen()"><i class="icon-remove-2 icon-large">&nbsp;</i></a>
                <a class="tip icon nounderline pointer" data-original-title="Save" data-placement="top" onclick="saveScreen()"><i class="icon-save icon-large">&nbsp;</i></a>
                <a class="tip icon nounderline pointer" data-original-title="Widgets" data-placement="top" onclick="toggleToolbox('widgetToolbox', '')"><i class="icon-dashboard icon-large">&nbsp;</i></a>
            </div>
        </div>
    </div>
    <div class="topbar" id="topbar">
        <ul id="topbarList" class="nav nav-tabs"></ul>
    </div>
    <div class="content">
        <div id="widgetSection" class="widgetCanvas">
            <!-- Main container -->
            <div id="widgetOptionMenu" class="dropdown" style="display: none; position: absolute">
                <!-- options for widgets -->
                <ul id="widgetOptionList" class="dropdown-menu" role="menu" style="display: inline;">
                    <li id="widgetOptionMenuDivider" class="divider"></li>
                    <li><a tabindex="-1"><input type="checkbox" id="zorder" data-type="zorder" />&nbsp;On Top</a></li>
                    <li><a tabindex="-1" onclick="helpWidget()">Help</a></li>
                    <li><a tabindex="-1" onclick="parent.modalDialog('text', 'Delete Widget', 'Confirm that you want to delete ' + widgets[editData.widgetNum].type + '?', 'Delete', 'deleteWidget')">Delete</a></li>
                    <li><a tabindex="-1" onclick="closeWidgetMenu('cancel')">Cancel</a></li>
                    <li><a tabindex="-1" onclick="closeWidgetMenu('save')">Close</a></li>
                </ul>
            </div>
            <div id="widgetContainer" style="position: absolute; left:0px; z-index: 0; height: 100%; width: 100%" onclick="canvasClick()">
                <canvas id="cvsDesign" style="display:none; z-index: 1; height: inherit; width: inherit"></canvas>
                <div id="widgetsDiv"></div>
                <div id="fade" style="display: inline; position: absolute; left:0px; height: 100%; width: 100%; opacity:0.5; background-color: white; z-index: 200"></div>
            </div>
        </div>
    </div>

    <script>
        "use strict";

        parent.profiler("dashloaded")

        var screens = [];
        var myScreen = function (name, icon) {
            this.name = name;
            this.icon = icon;
        }

        var channels = [];
        var channel = function (category, className, name, desc, type, IO, min, max, units) {
            this.category = category;
            this.className = className;
            this.name = name;
            this.desc = desc;
            this.type = type;
            this.IO = IO;
            this.min = min;
            this.max = max;
            this.units = units;
        }

        var widgets = [];
        var widget = function (type, ext, screen, locX, locY) {
            this.type = type;
            this.ext = ext;
            this.locX = locX;
            this.locY = locY;
            this.scaleX = 1;
            this.scaleY = 1;
            this.iniWidth = null;
            this.iniHeight = null;
            this.screen = screen;
            this.zOrder = 10;
            this.attribs = [];
            this.loadCnt = 0;
            this.flowNode = false;          //@@@@@@@@@
        };

        var plugins = [];
        var TBwidgets = [];
        var histReqs = [];

        // Generic property structure for widgets
        var widgetAttrib = function (name, type, value) {
            this.name = name;
            this.type = type;
            this.value = value;
        }

        var GRABSIZE = 8;                                                           // size of the grab rectangle block in design mode
        var DESIGNGRID = 10;                                                        // grid size in design mode
        var TBWIDGETWIDTH = 100;                                                    // width of the objects in the toolbox
        var WIDGETLOADRETRIES = 100;                                                // number of retries waiting for widget to load
        var ACTION_RETRY_MSEC = 2;                                                  // How long to retry waiting for widget
        var TBWIDTH = document.getElementById("widgetSection").offsetLeft           // Width of toolbox                                     //TODO: CAN BUT THIS IN THE DESIGN LOAD SECTION
        var TBYOFFSET = document.getElementById("widgetToolboxScroll").offsetTop    // Offset caused by toolbox header              //TODO: CAN BUT THIS IN THE DESIGN LOAD SECTION
        var WIDGETLOADTIMEOUT = 10000;                                              // Timeout waiting for widgets to load usually due to corrupt widget

        var widgetMax = { width: 1280, height: 900 };                               // maximum screen size for all screens used for UWP client
        var selScreenNum = 0;                                                       // selected screen
        var barList;                                                                // top or side lists
        var widgetToLoadCnt, widgetLoadedCnt;                                       // Counter for when the last widget has finished loading.
        var widgetSubscribe = "";                                                   // list of subscriptions
        var toolboxParam;                                                           // Save the toolbox parameter for other functions
        var tabIconSelected = "";                                                   // Save the name of the icon selected for saving
        var iniStr = "";                                                            // Store ini values for widgets while screen is loading
        var loadTimer;                                                              // Timeout for loading widgets

        var g = {}                                                                  // used for global boolean flags
        g.design = false                                                            // design mode flag
        g.loadedTB = false;                                                         // toolbox already loaded
        g.loadedScreen = false;                                                     // Flag for the screen widgets finished loading
        g.dirty = false;                                                            // changed without saving
        g.menuOpen = false;                                                         // widget edit menu state
        g.snapToGrid = true;                                                        // Flag to snap to grid for dragging widgets @@@
        g.flowEditor = false;                                                        // Using the flow editor @@@

        var editData = {};                                                          // Global object for tracking edit state
        var dragData = {};                                                          // Global object for tracking dragging state

        document.addEventListener("keydown", keyPress, true);                       // capture keypresses

        // API object injected into widgets for interaction with framework
        var widgetAPI = function (widgetName) {
            this.widgetName = widgetName;
            this.widgetNum = parseInt(widgetName.replace("widgetObj", "").replace("TB", ""));
            this.widgetID = document.getElementById(widgetName).contentDocument.getElementById("widget");                                           // widget element in the widget object

            this.state = "dashboard";
            if (widgetName.indexOf("TB") !== -1) this.state = "toolbox";
            else {
                this.attribs = widgets[this.widgetNum].attribs;
                this.scaleX = widgets[this.widgetNum].scaleX;
                this.scaleY = widgets[this.widgetNum].scaleY;
                this.iniHeight = widgets[this.widgetNum].iniHeight;
                this.iniWidth = widgets[this.widgetNum].iniWidth;
                if (g.design) this.state = "design";
            }

            // Access general framework functions from dashboard
            this.func = function (funcName, param0, param1, param2, param3) {
                var result = widgetRequest(widgetName, funcName, param0, param1, param2, param3);
                if (this.widgetName.substr(0, 11) !== "widgetObjTB") this.attribs = widgets[this.widgetNum].attribs;                                // reload attributes in case attribs are updated
                return result;
            }

            // send channel data to the host
            this.channelSend = function (channel, scope, data) {
                return widgetRequest(widgetName, "send", channel, scope, data);
            }
        }

        if (parent.deviceWidth < 1025) {                                                                                                            // Adjust screen based on width
            document.getElementById("sidebar").style["display"] = "none";
            document.getElementById("topbar").style["display"] = "inline";
            document.getElementById("widgetSection").className = "widgetCanvasMobile";
            barList = "topbarList";
        } else {
            document.getElementById("sidebar").style["display"] = "inline";
            document.getElementById("topbar").style["display"] = "none";
            barList = "sidebarList";
        }

        //////////////////////////////////////////// Widget design menu

        // Display modal with HTML help text for a widget being edited
        function helpWidget() {
            var widgetHelp = "No help found.";
            if (typeof editData.widgetView.help === "function") widgetHelp = editData.widgetView.help();
            parent.modalDialog("text", "Help for " + widgets[editData.widgetNum].type + " widget", widgetHelp);                                     // Display help string returned from help function in widget
        }

        // Display the widget menu based on the attributes available
        function showWidgetMenu(widgetName) {
            var widgetProp;
            var docFrag = document.createDocumentFragment();
            var menuItem = document.createElement("li");
            var menu = document.getElementById("widgetOptionMenu");
            var list = document.getElementById("widgetOptionList");
            var divider = document.getElementById("widgetOptionMenuDivider");
            var dropSel = [];
            var channelNum = 0;

            setEdit(widgetName);
            g.menuOpen = true;

            while (list.firstChild !== divider) list.removeChild(list.firstChild);                                                                  // clear list up to the divider
            menuItem.innerHTML = "<h5 class='text-center'><b>&nbsp;&nbsp;&nbsp;Configure " + widgets[editData.widgetNum].type + " widget&nbsp;&nbsp;&nbsp;</b></h5>";
            docFrag.appendChild(menuItem);

            for (var i = 0; i < widgets[editData.widgetNum].attribs.length; i++) {
                menuItem = document.createElement("li");
                widgetProp = widgets[editData.widgetNum].attribs[i].name;
                var innerHTML = "";

                switch (widgets[editData.widgetNum].attribs[i].type) {                                                                              // build the widget property menu based on attributes for the widget
                    case "dropdown":
                        var options = widgetProp.split(",")                                                                                         // options separated by commas
                        var selectName = "select" + dropSel.length                                                                                  // create an array in case there are multiple dropdowns
                        innerHTML = "<a tabindex='-1' href='#'><select id='" + selectName + "' data-type='dropdown' class='span2'>"
                        for (var j = 0; j < options.length; j++) {
                            innerHTML += "<option>" + options[j].trim() + "</option>";
                            if (options[j].trim() === widgets[editData.widgetNum].attribs[i].value) dropSel.push(j);
                        }
                        innerHTML += "</select></a>";
                        break;
                    case "checkbox":
                        var checked = "";
                        if (widgets[editData.widgetNum].attribs[i].value === true) checked = "checked";
                        innerHTML = "<a tabindex='-1' href='#'><label class='checkbox'><input type='checkbox' " + checked + " data-type='checkbox' />" + widgetProp + "</label></a>";
                        break;
                    case "channel":                                                                                                                 // if the channel name is blank, don't display it (hidden channel)
                        var chName = widgets[editData.widgetNum].attribs[i].value;
                        if (chName === "") chName = "none";
                        if (widgetProp !== "") innerHTML = "<a tabindex='-1' id='channelItem" + channelNum + "' href='#' data-selected='" + widgets[editData.widgetNum].attribs[i].value + "' data-type='channel' onclick='toggleToolbox(\"channelToolbox\", \"open\", " + channelNum + ")'>" + widgetProp + ": " + chName + "</a>";
                        channelNum = channelNum + 1;
                        break;
                    case "file":
                        innerHTML = "<a tabindex='-1' id='menuFile' href='#'>" + widgets[editData.widgetNum].attribs[i].value + "&nbsp;&nbsp<input id='selectedFile' type='file' accept='image/jpeg,image/png,image/gif' size='1' data-type='file' style='display: none'/><button onclick='fileInputHelper()'>File</button></a>";
                        break;
                    case "input":
                        innerHTML = "<a tabindex='-1' href='#'>" + widgets[editData.widgetNum].attribs[i].name + "&nbsp;&nbsp;<input type='text' class='form-control input-sm' value='" + widgets[editData.widgetNum].attribs[i].value + "' data-type='input' placeholder='" + widgets[editData.widgetNum].attribs[i].value + "'></a>";
                        break;
                    case "data":                                                                                                                    // store widget variables (hidden on option menu)
                        innerHTML = "<a data-type='data' style='display: none;'>" + widgets[editData.widgetNum].attribs[i].value + "</a>";
                        break;
                    default:
                }
                menuItem.innerHTML = innerHTML;
                docFrag.appendChild(menuItem);
            }

            list.insertBefore(docFrag, divider);

            for (var i = 0; i < dropSel.length; i++) {                                                                                              // set the default setting for each dropdown in the menu
                document.getElementById("select" + i).selectedIndex = dropSel[i];
            }

            menu.style.setProperty("display", "inline");

            if (widgets[editData.widgetNum].zOrder === 100) document.getElementById("zorder").checked = true;
            else document.getElementById("zorder").checked = false;

            menu.style.setProperty("left", parseInt(editData.widgetObj.offsetLeft) + ((parseInt(editData.widgetObj.offsetLeft) < window.innerWidth / 2) ? (parseInt(editData.widgetObj.width) + 5) : (-1 * (list.clientWidth))) + "px");
            menu.style.setProperty("top", parseInt(editData.widgetObj.offsetTop) + (((parseInt(editData.widgetObj.offsetTop) >= window.innerHeight / 2) ? (-1 * (list.clientHeight)) : 0)) + "px");  // adjust menu position based on location of widget so menu stays on the screen
        }

        // Helper for menu to select files. click the hidden file input tag and display selected file
        function fileInputHelper() {
            var selFile = document.getElementById("selectedFile");
            selFile.click();
            document.getElementById("menuFile").innerHTML = selFile.files[0].name + "&nbsp;&nbsp<input id='selectedFile' type='file' accept='image/*' size='1' data-type='file' style='display: none'/><button onclick='fileInputHelper()'>File</button>"
            document.getElementById("selectedFile").files[0] = selFile.files[0];                                                            // re-attach the selected file to the element as it gets destroyed when replacing the HTML
        }

        // Close widget menu and update with changes
        function closeWidgetMenu(option) {
            if (option === "save") {
                walkList(document.getElementById("widgetOptionList"), 0);                                                                           // recursive save all the menu settings based on nodes with widget data-type attribute
                if (typeof editData.widgetView.menuUpdate === "function") editData.widgetView.menuUpdate();                                         // call menu update routine in widget
            }
            if (option === "cancel") parent.status("Changes to widget '" + widgets[editData.widgetNum].type + "' cancelled.");
            resetEdit(editData.widgetName);
            document.getElementById("widgetOptionMenu").style.setProperty("display", "none");                                                       // hide option menu
            g.menuOpen = false;
        }

        // Save widget attribute data based on the values set in the widget option menu
        function walkList(node, optionCnt) {
            var children = node.childNodes;
            for (var i = 0; i < children.length; i++) {
                optionCnt = walkList(children[i], optionCnt);                                                                                       // recursive find lowest sibling
            }
            if (node.attributes && node.attributes["data-type"]) {
                switch (node.attributes["data-type"].nodeValue) {                                                                                   // build the widget property menu based on attributes for the widget
                    case "zorder":
                        if (node.checked) widgets[editData.widgetNum].zOrder = 100;
                        else widgets[editData.widgetNum].zOrder = 10;
                        editData.widgetObj.style.setProperty("z-index", widgets[editData.widgetNum].zOrder);
                        break;
                    case "checkbox":
                        widgets[editData.widgetNum].attribs[optionCnt].value = node.checked;
                        break;
                    case "channel":
                        widgets[editData.widgetNum].attribs[optionCnt].value = node.getAttribute("data-selected");
                        break;
                    case "dropdown":
                        widgets[editData.widgetNum].attribs[optionCnt].value = node.value.trim().toLowerCase();
                        break;
                    case "file":
                        if (typeof node.files[0] !== "undefined") {
                            var reader = new FileReader();
                            reader.onload = (function (widgetNum) {
                                return function (e) {
                                    if (event.target.result.toString().length > 139999) {
                                        alert("ERROR: File Size of " + parseInt(event.target.result.toString().length * 0.00074) + "K Bytes for image file '" + node.files[0].name + "' is too large. Select an image of size less than 100K Bytes instead.");
                                    } else {
                                        parent.send("WIDGETS", "FILE", "IMAGE," + widgetNum + "," + node.files[0].name + "," + event.target.result)
                                    }
                                };
                            })(editData.widgetNum);
                            reader.readAsDataURL(node.files[0]);                                                                                  // Read in as base64
                            widgets[editData.widgetNum].attribs[optionCnt].value = node.files[0].name
                        }
                        break;
                    case "input":
                        widgets[editData.widgetNum].attribs[optionCnt].value = node.value;
                        break;
                    case "data":
                        widgets[editData.widgetNum].attribs[optionCnt].value = node.innerHTML;
                        break;
                    default:
                }
                optionCnt += 1;
                g.dirty = true;
            }
            return optionCnt;
        }

        // Delete widget and reset edit mode
        function deleteWidget() {
            if (editData.widgetName) {
                parent.status("Deleted widget #" + editData.widgetNum + " (" + widgets[editData.widgetNum].type + ")");
                editData.widgetObj.parentNode.removeChild(editData.widgetObj);                                                                      // remove widget
                var allWidgets = document.querySelectorAll(".widget");
                for (var widgetNum = 0; widgetNum < allWidgets.length; widgetNum++) {                                                               // shuffle widget ID to adjust for deletion
                    var myWidgetNum = parseInt(allWidgets[widgetNum].id.replace("widgetObj", ""));
                    if (myWidgetNum > editData.widgetNum) {
                        allWidgets[widgetNum].id = "widgetObj" + (myWidgetNum - 1);                                                                 // Change widget name & number
                        allWidgets[widgetNum].contentDocument.defaultView.fw.widgetName = allWidgets[widgetNum].id;
                        allWidgets[widgetNum].contentDocument.defaultView.fw.widgetNum = myWidgetNum - 1;
                    }
                }
                widgets.splice(editData.widgetNum, 1);                                                                                              // remove widget from widget array
                closeWidgetMenu("deleted");
                g.dirty = true;
            }
        }

        //////////////////////////////////////////// Design mode

        // Setup design
        function setDesign() {
            if (!g.design) {
                if (g.loadedTB === false) {                                                                                                         // Initialise for the design environment (only run once)
                    parent.send((g.flowEditor ? "NODES" : "WIDGETS"), "TOOLBOX", "");                                                               // retrieve the available toolbox widget names from server
                    var cvs = document.getElementById("cvsDesign");
                    var canvas_ctx = cvs.getContext("2d");
                    cvs.width = parent.iFrame.clientWidth;                                                                                          // Actual width/height
                    cvs.height = parent.iFrame.clientHeight;
                    canvas_ctx.lineWidth = 1;
                    var cnt = 3;                                                                                                                    // adjust grid dimensions if impersonating another device like phone
                    for (var x = 1; x < parent.deviceWidth; x += DESIGNGRID) {
                        cnt = drawLine(x - 0.5, x - 0.5, 0.5, parent.deviceHeight - 0.5, cnt, canvas_ctx);
                    }
                    cnt = 3;
                    for (var y = 1; y < parent.deviceHeight; y += DESIGNGRID) {
                        cnt = drawLine(0.5, parent.deviceWidth - 0.5, y - 0.5, y - 0.5, cnt, canvas_ctx);
                    }
                    setTimeout(loadIcons, 50);                                                                                                      // Dont let loadicons delay as it can take time
                    g.loadedTB = true;
                }
                g.design = true;
                parent.status("Designer Mode");
                document.getElementById("cvsDesign").style.setProperty("display", "inline");
                document.getElementById("sideScreenEditor").style.setProperty("display", "inline");
                document.body.setAttribute("spellcheck", "true");

                var nodes = document.getElementById(barList).getElementsByTagName("span");
                for (var nodeNum = 0; nodeNum < nodes.length; nodeNum++) {
                    nodes[nodeNum].setAttribute("contenteditable", "true");                                                                         // Able to edit tab text
                }
                var allWidgets = document.querySelectorAll(".widget");
                for (var widgetNum = 0; widgetNum < allWidgets.length; widgetNum++) {                                                               // Loop through all widgets on screen and run the startdesign routine in the widget
                    if (typeof allWidgets[widgetNum].contentDocument.defaultView.startDesign === "function") allWidgets[widgetNum].contentDocument.defaultView.startDesign();
                    allWidgets[widgetNum].contentDocument.defaultView.fw.state = "design";
                }
            }
        }

        // Gridlines in the background canvas for design mode
        function drawLine(x1, x2, y1, y2, cnt, canvas_ctx) {
            if (cnt === 3) {
                canvas_ctx.strokeStyle = "rgb(207, 221, 232)";                                                                                      // Major gridline
                cnt = -1;
            }
            canvas_ctx.beginPath();
            canvas_ctx.moveTo(x1, y1);
            canvas_ctx.lineTo(x2, y2);
            canvas_ctx.stroke();
            cnt += 1;
            if (cnt === 0) canvas_ctx.strokeStyle = "rgb(221, 235, 246)";                                                                           // Minor gridline
            return cnt;
        }

        // Load widget toolbox with just the filtered widgets
        function filterWidgets() {
            document.getElementById("widgetToolboxScroll").innerHTML = "";                                                                          // clear toolbox
            var TBWidgetNames = ""
            for (var TBWidgetNum = 0; TBWidgetNum < TBwidgets.length; TBWidgetNum++) {
                TBWidgetNames = TBWidgetNames + TBwidgets[TBWidgetNum].type + ".html,";
            }
            initTBWidgets(TBWidgetNames.slice(0, -1), document.getElementById("widgetSearchTxt").value.trim());
        }

        // Load channel toolbox with just filtered channels
        function filterChannels() {
            loadChannels(document.getElementById("channelSearchTxt").value.trim(), false);
        }

        // Load icon toolbox with just filtered icons
        function loadIcons() {
            var filter = document.getElementById("iconSearchTxt").value;
            document.getElementById("iconToolboxScroll").innerHTML = "";                                                                            // Clear toolbox
            var docFrag = document.createDocumentFragment();                                                                                        // load icons into icon toolbox
            for (var sheet = 0; sheet < document.styleSheets.length; sheet++) {
                if (document.styleSheets[sheet].href.indexOf("icons.css") !== -1) {                                                                 // Only look in icons stylesheet
                    var cssRules = document.styleSheets[sheet].cssRules;
                    for (var rule = 0; rule < cssRules.length; rule++) {                                                                            // check all CSS rules
                        var selectorText = cssRules[rule].selectorText;
                        if (selectorText && (selectorText.indexOf(":before") !== -1)) {                                                             // Only process the icons (icomoon uses :before in the icon string)
                            if (selectorText.toLowerCase().indexOf(filter.toLowerCase()) !== -1) {                                                  // Apply any filter specified to narrow down list
                                var iconElement = document.createElement("li");
                                var iconbits = selectorText.split(":")
                                iconElement.innerHTML = "<i style='cursor: pointer' id='" + iconbits[0].slice(1) + "' class='" + iconbits[0].slice(1) + " icon-large'></i><br/>" + iconbits[0].slice(6) + "<br/>" + "<br/>"
                                docFrag.appendChild(iconElement);
                            }
                        }
                    }
                    break;
                }
            }
            document.getElementById("iconToolboxScroll").appendChild(docFrag);
        }

        // Open and close toolbox
        function toggleToolbox(toolboxName, openclose, param) {
            toolboxParam = param;
            if (document.getElementById(toolboxName).style.getPropertyValue("left") !== "0px") {
                if (openclose === "open" || openclose === "") document.getElementById(toolboxName).style.setProperty("left", "0px");
            } else if ((openclose === "close" || openclose === "")) document.getElementById(toolboxName).style.setProperty("left", "-200px");
            parent.status("");
        }

        //////////////////////////////////////////// Screens

        // Populate the screen object from initial connection data
        function initScreens(screensIni) {
            var myNode = document.getElementById(barList);
            while (myNode.firstChild) {
                myNode.removeChild(myNode.firstChild);                                                                                               // Remove old tabs if reloading due to errors
            }

            if (screensIni.length !== 0) {
                screens = screensIni;
                //screens = JSON.parse(screenJSON);
                for (var screen = 0; screen < screens.length; screen++) {
                    createTab(screen, false);
                }
            } else {
                if (parent.deviceWidth < 1025) parent.modalDialog("text", "First use", "Welcome to the home automation client. <br><br>As this is a small screen not ideal for designing screens, go to a desktop and impersonate the name of this device to setup its screens.", "Continue", "")
                else parent.modalDialog("text", "First use", "Welcome to the home automation client. <br><br>To get started, rename the 'New Screen' tab and use the Design Options icons on the bottom left corner to create or delete screens, save or use the widget toolbox to drag and add widgets. <br><br>Press the 'Help' button in the navigation bar and select 'Starting' for more instructions.", "Continue", "newDevice");
            }
        }

        function deleteScreen() {
            parent.modalDialog("text", "Delete Screen", "Confirm deletion of screen '" + screens[selScreenNum].name + "'.", "Delete", "removeScreen", selScreenNum);
        }

        // Callback from delete screen modal
        function removeScreen(screenNum) {
            var bar = document.getElementById(barList);                                                                                             // parent
            screens.splice(screenNum, 1);                                                                                                           // remove screen from array
            for (var widget = 0; widget < widgets.length; widget++) {                                                                               // remove all widgets on that screen
                if (widgets[widget].screen === screenNum) widgets.splice(widget, 1);
            }
            bar.removeChild(document.getElementById("ScreenLi-" + screenNum));
            if (bar.childElementCount > 0) {
                bar.firstElementChild.className = "active";                                                                                         // make the first element active
                selScreenNum = parseInt(bar.firstElementChild.id.split("-")[1]);
            }
            populateScreenWidgets();
        }

        // create a new screen tab
        function newScreen() {
            screens.push(new myScreen("New Screen", "icon-exclamation-sign"));
            var liNum = createTab(screens.length - 1, true);
            selectedTab(liNum);
            var range = document.createRange();                                                                                                     // set edit cursor to new tab
            var sel = window.getSelection();
            range.setStart(document.getElementById("screenTab-" + liNum).childNodes[1], 0);
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);
            parent.status("New screen created");
        }

        // create a tab screen
        function createTab(screenNum, edit) {
            var num = document.getElementById(barList).childElementCount;
            var iconElement = document.createElement("li");
            iconElement.id = "ScreenLi-" + num;
            iconElement.innerHTML = "<a tag='screenTab' data-toggle='tab' onclick='screenTabClick(this)' id='screenTab-" + num + "' style='cursor: pointer'><i onclick='tabIconClick(this)' class='" + screens[screenNum].icon + " icon-large'></i><span onblur='saveScreenText(this)' contenteditable='" + edit + "'>" + screens[screenNum].name + "</span></a>"
            document.getElementById(barList).appendChild(iconElement);
            return num;
        }

        // Load widgets onto screen
        function populateScreenWidgets(stopReload) {
            widgetToLoadCnt = 0;
            widgetLoadedCnt = 0;
            g.loadedScreen = false;

            if (!stopReload) {
                document.getElementById("fade").style.setProperty("display", "inline");                                                             // move offscreen to make for clean rendering
                setTimeout(populateScreenWidgets, 0, true);                                                                                         // Fade the screen by rendering
                return;
            }

            parent.profiler("startscreenload")      ////////////////

            var container = document.getElementById("widgetContainer");
            var newDiv = document.createElement("div");
            widgetSubscribe = "";

            for (var item = 0; item < widgets.length; item++) {
                if ((widgets[item].screen === selScreenNum)) {
                    loadWidget(newDiv, item);                                                                                                       // Load new widget to our new element
                    widgetToLoadCnt += 1;
                    for (var i = 0; i < widgets[item].attribs.length; i++) {                                                                        // cache channel to subscribe to
                        if (widgets[item].attribs[i].type === "channel" && widgets[item].attribs[i].value !== "") {                                 // don't duplicate subscription
                            if (widgetSubscribe.indexOf(widgets[item].attribs[i].value) === -1) widgetSubscribe = widgetSubscribe + widgets[item].attribs[i].value + ",";

                            /////// TODO: Work out what widgets from the old page are gone and remove their subscription in AfterRender if the subscription isn't needed by a new widget

                        }
                    }
                }
            }

            clearTimeout(loadTimer);                                                                                                                // Timeout if missing widgets during load (afterRender won't get called)
            loadTimer = setTimeout(loadTimeout, WIDGETLOADTIMEOUT);

            if (widgetToLoadCnt > 0) container.style.setProperty("left", "-5000px");                                                               // move offscreen to make for clean rendering only if not a new screen (without loading widgets screen back to 0 left won't be invoked)
            else parent.status("");

            newDiv.id = "widgetsDiv"
            container.replaceChild(newDiv, container.childNodes[3]);
            newDiv = null;                                                                                                                          // Garbage collect

            if (widgetSubscribe !== "") {
                widgetSubscribe = widgetSubscribe.slice(0, -1);                                                                                     // remove trailing comma & subscribe
                parent.send((g.flowEditor ? "NODES" : "WIDGETS"), "INISUB", widgetSubscribe);
                iniStr = "";
            }
        }

        // Save the contents of an edited sidebar tab
        function saveScreenText(me) {
            screens[me.parentNode.id.split("-")[1]].name = me.innerText;                                                                            // index is found in the parent ID after the '-'
        }

        function buildFlow(flowNum, flowOutPin, link) {
            branchObj[flowOutPin] = {};
            branchObj[flowOutPin].type = links[link].inpNodeType;
            branchObj[flowOutPin].attribs = widgets[+links[link].inpNodeNum].attribs;
        }

        var flowCompile = [];
        var branchObj;
        //Labelling flows
        function saveScreen() {
            // TEMPORARy @@@
            if (g.flowEditor) {
                //TODO: would it be easier to just use the flowCompile array and not the links array?
                var flowNum = 0;
                for (var flowLink = 0; flowLink < links.length; flowLink++) {       // test to see what nodes are have outputs but no inputs (ie. no links coming in) so are starting nodes
                    var foundInp = false
                    for (var testLink = 0; testLink < links.length; testLink++) {
                        if (links[flowLink].outNodeNum === links[testLink].inpNodeNum) {
                            foundInp = true;
                            break;
                        }
                    }
                    if (!foundInp) {                                                // New starting node found, walk its links
                        flowCompile.push({ "name": "Alarm", "desc": "Arm the alarm when exiting", start: { "type": links[flowLink].outNodeType, "attribs": widgets[+links[flowLink].outNodeNum].attribs } });
                        var currLink = flowLink;

                        branchObj = flowCompile[flowNum].start;
                        buildFlow(flowNum, 0, currLink);
                        // Find the next link on the same node
                        for (var nextLink = 0; nextLink < links.length; nextLink++) {
                            if (links[currLink].inpNodeNum === links[nextLink].outNodeNum) {
                                currLink = nextLink;                                                // walk the links
                                branchObj = branchObj[0]
                                buildFlow(flowNum, 0, currLink);
                            }
                        }
                        flowNum++;
                    }
                }
                return
            }
            if (editData.widgetName) resetEdit(editData.widgetName);                                                                                // turn off editing for any widget being edited
            if (screens.length !== 0) {
                for (var screenNum = 0; screenNum < screens.length; screenNum++) {
                    if (screens[screenNum].name === "New Screen") {
                        alert("ERROR, screen not saved - A screen has not been given a name, rename 'New Screen' to something else before saving.");
                        return;
                    }
                    for (var widgetNum = 0; widgetNum < widgets.length; widgetNum++) {
                        if (widgets[widgetNum].screen === screenNum) break;
                    }
                    if (widgetNum === widgets.length) alert("WARNING, Screen '" + screens[screenNum].name + "' does not have widgets and will be saved blank. Open toolbox and drag a widget to the screen before saving.");
                }
                g.dirty = false;
                parent.status("Screens saved.");
                //TODO: Save widget screens differently to nodes
                parent.send("SCREENS", "SAVE", JSON.stringify(screens));
                var saveWidgets = [];                                                                                                               // compress widgets to save bandwidth/speed
                for (var i = 0; i < widgets.length; i++) {
                    var widgetAttribs = [];
                    for (var y = 0; y < widgets[i].attribs.length; y++) {
                        widgetAttribs.push({ n: widgets[i].attribs[y].name, t: widgets[i].attribs[y].type, v: widgets[i].attribs[y].value });
                    }
                    saveWidgets.push({ t: widgets[i].type, e: widgets[i].ext, lX: widgets[i].locX, lY: widgets[i].locY, sX: (widgets[i].scaleX).toFixed(2), sY: (widgets[i].scaleY).toFixed(2), w: widgets[i].iniWidth, h: widgets[i].iniHeight, s: widgets[i].screen, d: widgets[i].device, z: widgets[i].zOrder, a: widgetAttribs })
                }
                parent.send((g.flowEditor ? "NODES" : "WIDGETS"), "SAVE", JSON.stringify(saveWidgets));
            } else {
                alert("Error, screen not saved - Create a screen first before saving by pressing the 'add' icon.")
            }
        }

        // selected a new screen tab
        function screenTabClick(e) {
            if ("screenTab-" + selScreenNum !== e.id) selectedTab(parseInt(e.id.split("-")[1]));                                                    // Dont reload currently selected screen
        }

        // selected a new screen tab via tab icon (allows us to change icons when editing screens)
        function tabIconClick(e) {
            selScreenNum = parseInt(e.parentNode.id.split("-")[1]);
            selectedTab(selScreenNum);
            if (g.design) {
                tabIconSelected = e.parentNode.id;
                toggleToolbox("iconToolbox", "open");
            }
        }

        // change the screen based on tab clicked
        //TODO: Needs to test that the screen is in the DOM first, not just the screen array as this errors out on slow machines
        function selectedTab(newScreenNum, firstLoad) {
            if (screens.length > 0) {
                document.getElementById(barList).childNodes[selScreenNum].className = "pointer";                                                    // make existing selected element not active
                endWidgetSess();
                parent.status("Loading new screen...");
                selScreenNum = newScreenNum;                                                                                                        // set global for functions setting new tab active
                document.getElementById(barList).childNodes[newScreenNum].className = "active";                                                     // make the selected element active
                populateScreenWidgets(firstLoad);
            }
        }

        // End widget sessions
        function endWidgetSess() {
            if (widgetSubscribe !== "") parent.send((g.flowEditor ? "NODES" : "WIDGETS"), "UNSUB", widgetSubscribe);                                   // TODO @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
            //var screenWidgets = document.querySelectorAll(".widget");
            //for (var widgetNum = 0; widgetNum < screenWidgets.length; widgetNum++) {                                                              // Run any end session functions in widgets
            //    if (!g.design && typeof screenWidgets[widgetNum].contentDocument.defaultView.endSession === "function") screenWidgets[widgetNum].contentDocument.defaultView.endSession()
            //}
        }

        // callback when an icon in the icontoolbox is selected
        function iconSel(event) {
            if (event.target.id !== "") {                                                                                                           // only select the event of the icon (other closeby elements dont have an id
                if (tabIconSelected !== "") {
                    document.getElementById(tabIconSelected).getElementsByTagName("i")[0].className = event.target.id + " icon-large";
                    toggleToolbox("iconToolbox", "close");
                    screens[selScreenNum].icon = event.target.id;
                    tabIconSelected = "";
                }
            }
        }

        //////////////////////////////////////////// Channels

        // Select the channel based on the global set by the toolbox
        function channelSel(event) {                                                                                                                // category, class and instance names stored in ID as category\class\channel
            if (event.target.id !== "" && typeof toolboxParam !== "undefined") {                                                                    // only select the event of the icon selected (other close by elements dont have an id)
                var channelItem = document.getElementById("channelItem" + toolboxParam);
                if (event.target.id === "noChannel") {
                    channelItem.setAttribute("data-selected", "");
                    channelItem.innerText = channelItem.innerText.split(":")[0].trim() + ": "
                } else {
                    channelItem.setAttribute("data-selected", event.target.id);        // save in element data
                    channelItem.innerText = channelItem.innerText.split(":")[0].trim() + ": " + event.target.id.split("/")[2] + " (" + event.target.id.split("/")[1] + ")"
                }
                toggleToolbox("channelToolbox", "close");
            }
        }

        // Load the channel toolbox
        function loadChannels(filter, start) {
            var ChContainer = document.getElementById("channelToolboxScroll");
            while (ChContainer.lastChild) ChContainer.removeChild(ChContainer.lastChild);                                                           // clear the channel container

            for (var plugin in plugins) {
                for (var item = 0; item < plugins[plugin].Channels.length; item++) {
                    if (plugins[plugin].Channels[item].Name.toLowerCase().trim().indexOf(filter.toLowerCase().trim()) !== -1 ||
                        plugins[plugin].ClassName.toLowerCase().trim().indexOf(filter.toLowerCase().trim()) !== -1 ||
                        plugins[plugin].Category.toLowerCase().trim().indexOf(filter.toLowerCase().trim()) !== -1 ||
                        filter === "") {                                                                                                        // filter elements
                        if (start) channels.push(new channel(plugins[plugin].Category, plugins[plugin].ClassName, plugins[plugin].Channels[item].Name, plugins[plugin].Channels[item].Desc, plugins[plugin].Channels[item].Type, plugins[plugin].Channels[item].IO, plugins[plugin].Channels[item].Min, plugins[plugin].Channels[item].Max, plugins[plugin].Channels[item].Units));
                        var channelIcon = parent.categories[parent.categories.map(function (e) { return e.Cat; }).indexOf(plugins[plugin].Category)].Icon;     // 0 index category is 'ALL' so add 1
                        var IOIcon;
                        var chElem = document.createElement("li");
                        chElem.style.setProperty("cursor", "pointer");
                        chElem.className = "tip"
                        chElem.setAttribute("data-original-title", plugins[plugin].Channels[item].Desc);
                        chElem.id = plugins[plugin].Category + "/" + plugins[plugin].ClassName + "/" + plugins[plugin].Channels[item].Name          // store the category, class and channel names in the ID field for future use
                        if (!plugins[plugin].Channels[item].IO) plugins[plugin].Channels[item].IO = ""
                        switch (plugins[plugin].Channels[item].IO.toLowerCase()) {                                                                  // select icon to represent channel direction
                            case "input":
                                IOIcon = "sort-up"
                                break;
                            case "output":
                                IOIcon = "sort-down"
                                break;
                            case "inputoutput":
                                IOIcon = "sort"
                                break;
                            default:
                                IOIcon = "question-mark"
                        }
                        chElem.innerHTML = "<i class='icon-" + IOIcon + "' icon-large>&nbsp;</i><i class='icon-" + channelIcon + " icon-large' id='" + plugins[plugin].Category + "/" + plugins[plugin].ClassName + "/" + plugins[plugin].Channels[item].Name + "'></i><br/>" + plugins[plugin].ClassName + "<br/>" + plugins[plugin].Channels[item].Name + "<br/><br/>"
                        ChContainer.appendChild(chElem);
                    }
                }
            }
        }

        //#region        //////////////////////////////////////////// load widgets

        // Load the widget toolbox
        function initTBWidgets(widgetNames, filter) {
            var frag = document.createDocumentFragment();
            var widgetTemplates = widgetNames.split(",");
            for (var widgetNum = 0; widgetNum < widgetTemplates.length; widgetNum++) {
                var widgetNameType = widgetTemplates[widgetNum].split(".")
                if (widgetNameType[0].toLowerCase().trim().indexOf(filter.toLowerCase().trim()) !== -1 || filter === "") {                          // filter search
                    TBwidgets.push(new widget(widgetNameType[0], widgetNameType[1]));
                    var widgetObj = document.createElement("object");
                    widgetObj.type = "text/html";
                    widgetObj.data = (g.flowEditor ? "nodes/" : "widgets/") + widgetTemplates[widgetNum] + parent.debugURL                                                      // location of widget (and not from cache if debugging)
                    widgetObj.setAttribute("data-type", widgetNameType[0]);
                    widgetObj.id = "widgetObjTB" + widgetNum;
                    var title = document.createElement("p");
                    title.innerHTML = "<span>" + widgetNameType[0] + "</span><br /><br />";
                    widgetObj.addEventListener("load", widgetTBloaded);
                    frag.appendChild(widgetObj);                                                                                                    // Add to toolbox Div
                    frag.appendChild(title);
                }
            }
            document.getElementById("widgetToolboxScroll").appendChild(frag);
        }

        // finish toolbox widget load
        function widgetTBloaded(e) {
            var loadDoc = e.currentTarget.contentDocument;
            var TBWidget = loadDoc.getElementById("widget");
            var widgetNum = parseInt(e.currentTarget.id.replace("widgetObjTB", ""));
            try {
                var widgetWidth = Math.min(TBWIDGETWIDTH, parseInt(TBWidget.style.getPropertyValue("width")) || parseInt(TBWidget.getAttribute("width")));
                var widgetHeight = Math.min(TBWIDGETWIDTH, parseInt(TBWidget.style.getPropertyValue("height")) || parseInt(TBWidget.getAttribute("height")));
                e.currentTarget.width = widgetWidth;
                e.currentTarget.height = widgetHeight;
                loadDoc.defaultView.widgetLoad(e.currentTarget.id);                                                                                 // Run the widget API startup (must be done from parent to pass name)
                loadDoc.defaultView.fw.iniWidth = widgetWidth;
                loadDoc.defaultView.fw.iniHeight = widgetHeight;
                if (typeof loadDoc.defaultView.scale === "function") loadDoc.defaultView.scale(1, 1);
                if (typeof loadDoc.defaultView.toolStart === "function") loadDoc.defaultView.toolStart();
                TBWidget.style.setProperty("cursor", "move");
                widgetListeners(loadDoc);
                $("#" + e.currentTarget.id).tooltip({ title: loadDoc.getElementById("TBtooltip").getAttribute("data-default"), delay: { show: 2000 } });
            } catch (err) {
                e.currentTarget.parentNode.removeChild(e.currentTarget);                                                                            // remove widget
                alert("WARNING - widget '" + TBwidgets[widgetNum].type + "' is corrupt and won't be usable in the toolbox. " + err.toString());
                TBwidgets.splice(widgetNum, 1);
            }
        }

        // Initialise the widgets from initial connection load
        function initWidgets(widgetsIni) {
            if (widgetsIni.length !== 0) {
                //var serverWidgets = JSON.parse(widgetsJSON)
                for (var i = 0; i < serverWidgets.length; i++) {
                    if (serverWidgets[i].lX + serverWidgets[i].w > widgetMax.width) widgetMax.width = serverWidgets[i].lX + serverWidgets[i].w;
                    if (serverWidgets[i].lY + serverWidgets[i].h > widgetMax.height) widgetMax.height = serverWidgets[i].lY + serverWidgets[i].h;
                    var myWidget = new widget(serverWidgets[i].t, serverWidgets[i].e, serverWidgets[i].s, serverWidgets[i].lX, serverWidgets[i].lY);
                    myWidget.scaleX = +serverWidgets[i].sX;
                    myWidget.scaleY = +serverWidgets[i].sY;
                    myWidget.iniWidth = +serverWidgets[i].w;
                    myWidget.iniHeight = +serverWidgets[i].h;
                    myWidget.zOrder = serverWidgets[i].z;
                    for (var y = 0; y < serverWidgets[i].a.length; y++) {
                        myWidget.attribs.push({ name: serverWidgets[i].a[y].n, type: serverWidgets[i].a[y].t, value: serverWidgets[i].a[y].v });
                    }
                    widgets.push(myWidget);                                                                                                         // rehydrate widget compressed for faster network
                }
                if (typeof uwpHost !== "undefined") uwpHost.func("setMaxSize", widgetMax.width, widgetMax.height);                                          // for sett hosting, set screen size
            }
            selectedTab(0, true);                                                                                                                   // load the first screen & don't show screen fade for faster startup
        }

        // Create widgets
        function loadWidget(myFrag, widgetNum) {
            var widgetObj = document.createElement("object");
            widgetObj.type = "text/html";
            widgetObj.data = (g.flowEditor ? "nodes/" : "widgets/") + widgets[widgetNum].type + "." + widgets[widgetNum].ext + parent.debugURL                                  // location of widget
            widgetObj.className = "widget";
            widgetObj.id = "widgetObj" + widgetNum;
            widgetObj.addEventListener("load", widgetLoaded, false);
            myFrag.appendChild(widgetObj);                                                                                                          // build widgets onto fragment
        }

        // finish widget setup once the widget is loaded
        function widgetLoaded(e) {
            var loadObj = e.currentTarget;                                                                                                          // Object in parent.
            var loadNum = parseInt(loadObj.id.replace("widgetObj", ""));
            var loadDoc = loadObj.contentDocument;
            var widgetID = loadDoc.getElementById("widget");                                                                                        // Main element inside object
            try {
                if (g.design) {                                                                                                                     // setup initial settings when the widget is first created
                    widgets[loadNum].iniHeight = parseInt(widgetID.style.getPropertyValue("height")) || parseInt(widgetID.getAttribute("height"));
                    widgets[loadNum].iniWidth = parseInt(widgetID.style.getPropertyValue("width")) || parseInt(widgetID.getAttribute("width"));
                    for (var i = 0; true; i++) {                                                                                                    // read the data attributes from the SPAN tags to populate attrib array
                        var attribID = loadDoc.getElementById("attrib" + i);
                        if (!attribID) break;
                        widgets[loadNum].attribs.push(new widgetAttrib(attribID.getAttribute("data-name"), attribID.getAttribute("data-type"), attribID.getAttribute("data-default")));
                    }
                    if (loadDoc.getElementById("ontop").getAttribute("data-default") === "true") widgets[loadNum].zOrder = 100;
                    dragData.widgetObj = loadObj;                                                                                                   // drag from toolbox needs to wait until widget created
                    widgetID.style.setProperty("cursor", "move");
                    widgetListeners(loadDoc);
                }

                loadDoc.defaultView.widgetLoad(loadObj.id);                                                                                         // Run the widget API startup (must be done from parent to pass name)
                if (g.design && typeof loadDoc.defaultView.startDesign === "function") loadDoc.defaultView.startDesign();

                loadObj.setAttribute("style", "position:absolute;overflow:hidden;left:" + widgets[loadNum].locX + "px;top:" + widgets[loadNum].locY + "px;z-index:" + widgets[loadNum].zOrder);
                loadObj.width = widgets[loadNum].scaleX * widgets[loadNum].iniWidth
                loadObj.height = widgets[loadNum].scaleY * widgets[loadNum].iniHeight

                widgetLoadedCnt += 1;
                var startRet = "OK";
                if (typeof loadDoc.defaultView.dashStart === "function") var startRet = loadDoc.defaultView.dashStart();
                if (startRet.toUpperCase() !== "OK") throw "Widget failed startup - " + startRet;

                if (typeof loadDoc.defaultView.scale === "function") loadDoc.defaultView.scale(widgets[loadNum].scaleX, widgets[loadNum].scaleY);   // widget handles scaling for internal elements

                if (widgetToLoadCnt === widgetLoadedCnt) setTimeout(afterRender, 0);                                                                // Finished loading all the widgets on the screen, use timeout to render screen here

            } catch (err) {
                loadObj.parentNode.removeChild(loadObj);                                                                                            // remove widget
                if (parent.debugURL !== "") throw err.stack || err;                                                                                 // let debugger catch the error if debugging
                clearTimeout(loadTimer);
                alert("WARNING - Problems loading widget #" + loadNum + " (" + widgets[loadNum].type + "). Widget won't be useable. Details: " + err);         // else show the user a nice error box
                loadTimer = setTimeout(loadTimeout, WIDGETLOADTIMEOUT);                                                                             // Timeout if missing widgets during load (afterRender won't get called)
                widgets[loadNum].type = null;
            }
        }

        // Display screen as fast as possible, put non essential tasks to finish widget loading here
        function afterRender() {
            g.loadedScreen = true;
            if (iniStr !== "") widgetIni(iniStr);                                                                                                   // Display ini values if server responds faster than client screen render
            document.getElementById("fade").style.setProperty("display", "none");                                                                   // finally show the widgets!
            document.getElementById("widgetContainer").style.setProperty("left", "0px");
            parent.status("Ready");
            parent.enableTooltip();
            clearTimeout(loadTimer);
            var myWidgets = document.getElementsByClassName("widget");
            for (var i = 0; i < myWidgets.length; i++) if (myWidgets[i].contentDocument) widgetListeners(myWidgets[i].contentDocument.defaultView);
            if (!g.design && parent.mode === "Design") setDesign();                                                                                 // Go into design mode if just reloaded after pressing design button
            //parent.profiler("show")
        }

        function widgetListeners(myWidget) {
            myWidget.addEventListener("contextmenu", function (event) { event.preventDefault(); return false; });                                   // stop browser right click menu
            myWidget.addEventListener('mousemove', mouseMove, false);
            myWidget.addEventListener('mouseup', mouseUp, false);
            myWidget.addEventListener('mousedown', mouseDown, false);
            myWidget.addEventListener("dblclick", widgetDblClick, false);
        }

        // Not all widgets loaded, handle error
        function loadTimeout() {
            var loadedWidgets = document.getElementsByClassName("widget");
            var screenWidgets = widgets.filter(function (x) { return x.screen === selScreenNum });
            var counts = {};
            screenWidgets.forEach(function (x) { counts[x.type] = (counts[x.type] || 0) + 1; });                                                    // Count the number of different widgets defined for screen
            for (var countWidget in counts) {
                var foundWidgetNum = 0;
                for (var i = 0; i < loadedWidgets.length; i++) {
                    if (loadedWidgets[i].getAttribute("data").indexOf(countWidget) > -1 && loadedWidgets[i].width !== "") foundWidgetNum += 1       // Check to see if I have the same count per widget loaded
                }
                if (foundWidgetNum !== counts[countWidget]) alert("WARNING - Timed out waiting for widget (" + countWidget + ") which is corrupt or missing and didn't load. Some functionality may not work.");
            }
            afterRender();                                                                                                                          // Complete loading minus bad widget
        }

        ///////////////////////////////////////////////// Widget mouse events

        //BUG: On slower machines when dragging a new widget the widget can't keep up with the mouse and can't reconnect (touching the widget sends it flying away,...)
        // Handle mouse click over widget depending on mode
        function mouseDown(event) {
            if (g.design) {
                dragData.widgetName = event.target.ownerDocument.defaultView.fw.widgetName;
                dragData.widgetNum = parseInt(dragData.widgetName.replace("widgetObj", ""));
                dragData.widgetObj = document.getElementById(dragData.widgetName);
                if (dragData.widgetName.indexOf("TB") === -1) {                                                                                 // Dragging existing widget
                    dragData.startX = parseInt(dragData.widgetObj.style.left) - event.screenX;
                    dragData.startY = parseInt(dragData.widgetObj.style.top) - event.screenY;
                } else {
                    var TBWidgetNum = parseInt(event.currentTarget.defaultView.fw.widgetNum);                                                   // Setup widget just dragged to canvas
                    var TBWidget = document.getElementById("widgetObjTB" + TBWidgetNum);
                    dragData.startX = TBWidget.offsetLeft - event.screenX;
                    dragData.startY = TBWidget.offsetTop - document.getElementById("widgetToolboxScroll").scrollTop - event.screenY + TBYOFFSET;
                    dragData.newWidget = true;
                    dragData.widgetNum = widgets.length;
                    dragData.widgetName = "widgetObj" + dragData.widgetNum;

                    widgets.push(new widget(TBwidgets[TBWidgetNum].type, TBwidgets[TBWidgetNum].ext, selScreenNum, TBWidget.offsetLeft, TBWidget.offsetTop - document.getElementById("widgetToolboxScroll").scrollTop + TBYOFFSET));
                    var frag = document.createDocumentFragment();
                    loadWidget(frag, dragData.widgetNum);                                                                                           // create new widget if dragging from widget template & don't run widget startup routine as attribs have not been set
                    document.getElementById("mainBody").appendChild(frag);                                                                          // Add object to body so it can be dragged over everything
                }
                document.addEventListener('mousemove', mouseMove, false);                                                                       // For smoother scrolling
                g.dirty = true;
                event.preventDefault();                                                                                                     // stop HTML5 drag drop (also stops contenteditable)
            } else if (typeof event.currentTarget.clicked === "function") event.currentTarget.clicked(event);                                       // run the click event in the widget
        }

        // Handle mouse moving over widget depending on mode (drag new widget from toolbox, drag existing widget)
        function mouseMove(event) {
            if (dragData.widgetName) {                                                                                                              // Adjust the widget position if dragging
                if (dragData.widgetObj) {                                                                                                       // only drag if not rescaling & if I'm a new widget from the toolbox I have been created
                    dragData.widgetObj.style.setProperty("left", (dragData.startX + event.screenX) + "px");
                    dragData.widgetObj.style.setProperty("top", (dragData.startY + event.screenY) + "px");
                }
            } else if (typeof event.currentTarget.mouseMove === "function") event.currentTarget.mouseMove(event);                                   // Send mousemove to widget if it wants it
            //TODO: Do this elsewhere to avoid slowing the drag down?
            ///if (typeof uwpHost !== "undefined") uwpHost.func(setMaxSize, widgetMax.width, widgetMax.height);
        }

        // Handle widget mouse up depending on mode (edit mode set here not on mousedown as we could be dragging with mousedown)
        function mouseUp(event) {
            if (g.design) {
                if (event.which === 3) {                                                                                                            // right click
                    showWidgetMenu(event.target.ownerDocument.defaultView.fw.widgetName);                                                           // in design mode, show the widget menu
                    if (typeof event.currentTarget.designRHClicked === "function") event.currentTarget.designRHClicked(event);                      // run the click event in the widget
                } else {
                    if (dragData.widgetNum === undefined) {
                        alert("didn't get widgetNum")
                        return
                    }
                    if (!editData.scaling && widgets[dragData.widgetNum].locX === parseInt(dragData.widgetObj.style.left) && widgets[dragData.widgetNum].locY === parseInt(dragData.widgetObj.style.top)) {
                        if (setEdit(dragData.widgetName) === -1) resetEdit(dragData.widgetName);                                                        // Toggle edit mode if widget hasn't been dragged
                    }
                    if (dragData.newWidget) {
                        if (dragData.widgetObj.offsetLeft < TBWIDTH) dragData.widgetObj.style.setProperty("left", TBWIDTH + "px");                      // Move widget over to canvas if dropped on the toolbox
                        dragData.widgetObj.style.setProperty("left", parseInt(dragData.widgetObj.style.getPropertyValue("left")) - TBWIDTH + "px");     // adjust for widgetcontainer offset
                        dragData.widgetObj.contentDocument.getElementById("widget").style.setProperty("cursor", "default");
                        document.getElementById("widgetsDiv").appendChild(dragData.widgetObj);                                                          // Move from body to widget container
                        if (typeof dragData.widgetObj.contentDocument.defaultView.newWidget === "function") dragData.widgetObj.contentDocument.defaultView.newWidget();         // widget created routine in widget
                        g.dirty = true;
                    }
                    if (g.snapToGrid) {
                        dragData.widgetObj.style.setProperty("left", Math.round(parseInt(dragData.widgetObj.style.getPropertyValue("left")) / DESIGNGRID) * DESIGNGRID + "px");
                        dragData.widgetObj.style.setProperty("top", Math.round(parseInt(dragData.widgetObj.style.getPropertyValue("top")) / DESIGNGRID) * DESIGNGRID + "px");
                    }
                    widgets[dragData.widgetNum].locX = parseInt(dragData.widgetObj.style.left);
                    widgets[dragData.widgetNum].locY = parseInt(dragData.widgetObj.style.top);
                }
                dragData = {};
                document.removeEventListener('mousemove', mouseMove, false);
            }
        }

        ////////////////////////////////////////// widget edit state

        function setEdit(widgetName) {
            if (editData.widgetName === widgetName) return -1;                                                                                      // Don't run setEdit on the same widget if it is already being edited
            if (editData.widgetName) resetEdit(editData.widgetName);                                                                                // turn off edit mode for any widget currently being edited

            editData.widgetNum = parseInt(widgetName.slice(9));                                                                                     // Setup various DOM pointers
            editData.widgetName = widgetName;
            editData.widgetObj = document.getElementById(widgetName);
            editData.widgetEl = editData.widgetObj.contentDocument.getElementById("widget");
            editData.widgetView = editData.widgetObj.contentDocument.defaultView;

            if (typeof editData.widgetView.startEdit === "function") {                                                                              // Run widget edit function
                if (editData.widgetView.startEdit() === false) return;                                                                              // Widget doesn't want to be edited
            }

            parent.status("Editing widget #" + editData.widgetNum + " (" + widgets[editData.widgetNum].type + ")");
            editData.widgetObj.style.setProperty("outline", "gray dotted 1px")

            var dragBoxes = document.createElement("div");                                                                                          // Create drag holders
            dragBoxes.id = "dragHdls";
            dragBoxes.appendChild(dragBox("n-resize", "dragY", "50%", "0px"));
            dragBoxes.appendChild(dragBox("e-resize", "dragX", "0px", "50%"));
            dragBoxes.appendChild(dragBox("se-resize", "dragXY", "0px", "0px"));
            dragBoxes.setAttribute("style", "position:absolute; left:" + widgets[editData.widgetNum].locX + "px; top:" + widgets[editData.widgetNum].locY + "px; height:" + editData.widgetView.innerHeight + "px; width:" + editData.widgetView.innerWidth + "px; z-index:998");                       // ensure elements stay on top

            ///// STRANGE BUG - WON"T ALLOW EDITING OF WIDGET #0 WHEN DRAGHLDS ATTACHED

            document.getElementById("widgetsDiv").appendChild(dragBoxes);
            editData.dragHdls = document.getElementById("dragHdls");

            editData.widgetView.fw.state = "edit";
            //if (typeof editData.widgetView.startEdit === "function") editData.widgetView.startEdit();
        }

        function dragBox(cursor, id, right, bottom) {
            var dragEl = document.createElement("div");
            dragEl.setAttribute("id", id);
            dragEl.setAttribute("style", "border: solid gray; border-width:2px; position:absolute; z-index:998; cursor:" + cursor + "; right:" + right + "; width:" + GRABSIZE + "px; bottom:" + bottom + "; height:" + GRABSIZE + "px");
            dragEl.addEventListener("mousedown", widgetResizeStart, false);                                                                         // start resize when pressing mouse on the resize handle
            return dragEl;
        }

        function resetEdit(widgetName) {
            document.getElementById("widgetOptionMenu").style.setProperty("display", "none");                                                       // cancel widget option menu if open
            if (typeof editData.widgetView == "undefined") return -1;
            if (typeof editData.widgetView.endEdit === "function") if (editData.widgetView.endEdit() === -1) return -1;                             // call widget end edit routine, if it returns -1, then don't reset edit state

            editData.widgetView.fw.state = "design";
            editData.widgetObj.style.setProperty("outline", "none");
            if (editData.dragHdls) editData.dragHdls.parentNode.removeChild(editData.dragHdls);
            editData = {};

            parent.status("Designer mode");
        }

        /////////////////////////////////////////////// widget resize

        function widgetResizeStart(event) {
            editData.dragID = event.currentTarget.getAttribute("id");
            editData.startX = event.screenX - (widgets[editData.widgetNum].scaleX - 1) * widgets[editData.widgetNum].iniWidth;                      // mouse absolute position in the widgetcontainer
            editData.startY = event.screenY - (widgets[editData.widgetNum].scaleY - 1) * widgets[editData.widgetNum].iniHeight;
            editData.initialWidth = editData.widgetView.innerWidth / widgets[editData.widgetNum].scaleX;
            editData.initialHeight = editData.widgetView.innerHeight / widgets[editData.widgetNum].scaleY;

            if (editData.dragID === "dragX") editData.dragHdls.style.setProperty("cursor", "e-resize");
            if (editData.dragID === "dragY") editData.dragHdls.style.setProperty("cursor", "n-resize");
            if (editData.dragID === "dragXY") editData.dragHdls.style.setProperty("cursor", "se-resize");

            //TODO: Would this be easier if we just put one listener on the whole IFrame (document.addEventListener)?
            var allWidgets = document.querySelectorAll(".widget");
            for (var i = 0; i < allWidgets.length; i++) {
                addScaleListeners(allWidgets[i].contentDocument);                                                                                   // As <objects> swallow events, need to put listeners on each widget on the canvas to allow mouse to move over another widget when resizing
            }
            addScaleListeners(document.getElementById("dragHdls"));
            addScaleListeners(document.getElementById("cvsDesign"));
            addScaleListeners(document.getElementById("widgetContainer"));

            editData.scaling = true;
            event.stopPropagation();                                                                                                                // Don't bubble up to widget mousedown event
        }

        function addScaleListeners(obj) {
            obj.addEventListener("mousemove", mouseMoveDrag, false);
            obj.addEventListener("mouseup", widgetResizeEnd, false);
        }

        // only allow either X dragging, Y dragging, or proportional XY dragging
        function mouseMoveDrag(event) {
            if (editData.scaling) {
                var sizeChange;
                if (editData.dragID !== "dragY") {
                    var newWidth = Math.round((editData.initialWidth + event.screenX - editData.startX) / DESIGNGRID) * DESIGNGRID;                 // only allow grid gap increments
                    if (newWidth <= 0) return false;                                                                                                // Don't scale negative
                    editData.widgetObj.width = newWidth;
                    sizeChange = "Width: " + parseInt(newWidth * 100 / editData.initialWidth) + "%";
                    widgets[editData.widgetNum].scaleX = newWidth / editData.initialWidth;

                    editData.widgetEl.style.setProperty("width", newWidth + "px");
                    editData.dragHdls.style.setProperty("width", newWidth + "px");
                }
                if (editData.dragID !== "dragX") {
                    var newHeight = Math.round((editData.initialHeight + event.screenY - editData.startY) / DESIGNGRID) * DESIGNGRID;
                    sizeChange = "Height: " + parseInt(newHeight * 100 / editData.initialHeight) + "%";

                    if (editData.dragID === "dragXY") {
                        newHeight = widgets[editData.widgetNum].scaleX * editData.initialHeight;                                                    // For XY drag, only scale with X to preserve widget proportions
                        sizeChange = "Size: " + parseInt(newWidth * 100 / editData.initialWidth) + "%";
                    }
                    if (newHeight <= 0) return false;                                                                                               // Don't scale negative
                    editData.widgetObj.height = newHeight;
                    widgets[editData.widgetNum].scaleY = newHeight / editData.initialHeight;

                    editData.widgetEl.style.setProperty("height", newHeight + "px");
                    editData.dragHdls.style.setProperty("height", newHeight + "px");
                }
                if (typeof editData.widgetView.scale === "function") editData.widgetView.scale(widgets[editData.widgetNum].scaleX, widgets[editData.widgetNum].scaleY);
                parent.status(sizeChange);
                event.preventDefault();
                //event.stopPropagation();                                                                                                                // Don't bubble up to widget mousedown event
            }
        }

        function widgetResizeEnd(event) {
            editData.scaling = false;
            var allWidgets = document.querySelectorAll(".widget");
            for (var i = 0; i < allWidgets.length; i++) {
                removeScaleListeners(allWidgets[i].contentDocument);
            }

            removeScaleListeners(document.getElementById("dragHdls"));
            removeScaleListeners(document.getElementById("cvsDesign"));
            removeScaleListeners(document.getElementById("widgetContainer"));

            editData.widgetEl.style.setProperty("cursor", "default");
            g.dirty = true;
        }

        function removeScaleListeners(obj) {
            obj.removeEventListener("mousemove", mouseMoveDrag, false);
            obj.removeEventListener("mouseup", widgetResizeEnd, false);
        }

        ///////////////////////////////////////////// widget events

        // Click the canvas blank areas (not widgets)
        function canvasClick() {
            if (g.design && editData.widgetNum) resetEdit(editData.widgetName);                                                                     // turn off editing for any widget being edited
            return false;
        }

        // Double click the widget
        function widgetDblClick(event) {
            if (typeof event.currentTarget.dblClicked === "function") event.currentTarget.dblClicked(event);
            return false;
        }

        // Process global keypresses, handle for designer and send to widgets if they want it
        function keyPress(e) {
            if (g.design && editData.widgetName && !g.menuOpen) {
                switch (e.keyCode) {
                    case 13:                    // Enter
                        break;
                    case 46:                    // Del
                        parent.modalDialog('text', 'Delete Widget', 'Confirm that you want to delete ' + widgets[editData.widgetNum].type + '?', 'Delete', 'deleteWidget', editData.widgetNum)
                        break;
                    case 27:                    // ESC
                        closeWidgetMenu("cancel");
                        break;
                    case 37:                    // Left arrow
                        editData.widgetObj.style.setProperty("left", (widgets[editData.widgetNum].locX - DESIGNGRID) + "px");                       // move editing widget left by a grid space
                        widgets[editData.widgetNum].locX -= DESIGNGRID;
                        g.dirty = true;
                        break;
                    case 38:                    // Up arrow
                        editData.widgetObj.style.setProperty("top", (widgets[editData.widgetNum].locY - DESIGNGRID) + "px");                        // move editing widget up by a grid space
                        widgets[editData.widgetNum].locY -= DESIGNGRID;
                        g.dirty = true;
                        break;
                    case 39:                    // Right arrow
                        editData.widgetObj.style.setProperty("left", (widgets[editData.widgetNum].locX + DESIGNGRID) + "px");                       // move editing widget right by a grid space
                        widgets[editData.widgetNum].locX += DESIGNGRID;
                        g.dirty = true;
                        break;
                    case 40:                    // Down arrow
                        editData.widgetObj.style.setProperty("top", (widgets[editData.widgetNum].locY + DESIGNGRID) + "px");                        // move editing widget down by a grid space
                        widgets[editData.widgetNum].locY += DESIGNGRID;
                        g.dirty = true;
                        break;
                    default:
                }
            }
            var allWidgets = document.querySelectorAll(".widget");                                                                                  // send keypress to widgets if they want them
            for (var i = 0; i < allWidgets.length; i++) {
                if (typeof allWidgets[i].contentDocument.defaultView.keyPress === "function") allWidgets[i].contentDocument.defaultView.keyPress(e.keyCode);
            }
            return false;
        }

        // TEMPORARY WRAPPER UNTIL CUT OVER TO NEW MODEL
        function recvHostWrap(topic, data) {
            var topics = topic.split("/")
            recvHost({ Category: topics[0], ClassName: topics[1], Instance: topics[2], Scope: topics[3], Data: data });
        }

        // Process messages received from host
        //TODO: Refactor to a separate topic & data structure based on new model
        function recvHost(msg) {
            switch (msg.ClassName.toUpperCase()) {
                case "INITLOAD":
                    initScreens(msg.Data.Screens);
                    initWidgets(msg.Data.Widgets);                                                                                                  // show the tabs then load widgets
                    break;
                case "SCREENS":
                    switch (msg.Scope.toUpperCase()) {
                        case "LOAD":                                                                    // Not used but could be modified for loading specific screens
                            initScreens(msg.Data);
                            break;
                        default:
                    }
                    break;
                case "HISTORY":
                    (function (myMsg) {                                                                                                             // closure used as msg changes while waiting for data to load
                        for (var history = 0; history < histReqs.length; history++) {
                            if (histReqs[history].channel = myMsg.Scope) {
                                widgetAction("widgetObj" + histReqs[history].widgetNum, "history", myMsg.Scope.split("/")[2], histReqs[history].range, myMsg.Data);
                                histReqs.splice(history, 1)                                                                                         // remove from request cache
                                break;
                            }
                        }
                    })(msg);
                    break;
                case "WIDGETS":
                    switch (msg.Scope.toUpperCase()) {
                        case "LOAD":
                            initWidgets(msg.Data);
                            break;
                        case "TOOLBOX":
                            initTBWidgets(msg.Data, "");
                            break;
                        case "CHANNELS":
                            plugins = JSON.parse(msg.Data);
                            loadChannels("", true);
                            break;
                        case "IMAGE":                                                                                                   // &&&&&&&&&&&&&&&&&&&&&&&& TODO: Consider making this more generic rather than hard coded for the image widget
                            widgetAction("widgetObj" + msg.Data, "load");
                            break;
                        case "INISUB":                                                                                                              // initial state information from host plugins widgets subscribed to
                            if (msg.Data !== "{}") {
                                if (g.loadedScreen) widgetIni(msg.Data);
                                else iniStr = msg.Data;                                                                                             // Save ini values if not loaded
                            }
                            break;
                        default:
                    }
                    break;
                default:                                                                                                                            // General network message, send to subscribed widgets
                    for (var widgetNum = 0; widgetNum < widgets.length; widgetNum++) {
                        if (!g.design && widgets[widgetNum].screen === selScreenNum) {
                            for (var attrib = 0; attrib < widgets[widgetNum].attribs.length; attrib++) {
                                if (widgets[widgetNum].attribs[attrib].type === "channel") {
                                    if (widgets[widgetNum].attribs[attrib].value.toUpperCase() === msg.Category.toUpperCase() + "/" + msg.ClassName.toUpperCase() + "/" + msg.Instance.toUpperCase()) {
                                        widgetAction("widgetObj" + widgetNum, "feed", msg.Instance, msg.Scope, msg.Data);
                                    }
                                }
                            }
                        }
                    }
            }
        }

        // Set the initial state of the widgets based on the server return of state data when screen is initialised
        function widgetIni(widgetParams) {
            var cacheData = JSON.parse(widgetParams);
            for (var cacheCh in cacheData) {                                                                                                        // data in the format key "category/class/instance" data "scope:value, .." where category/class/instance is the channel name
                for (var widgetNum = 0; widgetNum < widgets.length; widgetNum++) {
                    if ((widgets[widgetNum].screen === selScreenNum)) {                                                                             // only action for active widgets on the screen
                        for (var attrib = 0; attrib < widgets[widgetNum].attribs.length; attrib++) {                                                // go looking through widget attributes for a channel
                            if (widgets[widgetNum].attribs[attrib].type === "channel" && widgets[widgetNum].attribs[attrib].value === cacheCh) {
                                var splitParams = cacheData[cacheCh].indexOf(":")
                                widgetAction("widgetObj" + widgetNum, "ini", cacheCh.split("/")[2], cacheData[cacheCh].substr(0, splitParams), cacheData[cacheCh].substr(splitParams + 1))
                            }
                        }
                    }
                }
            }
        }

        // Main interface for requests coming from widgets for framework services
        function widgetRequest(widgetName, func, param0, param1, param2, param3) {
            var widgetNum = parseInt(widgetName.slice(9));
            var widgetObj = document.getElementById(widgetName);
            switch (func.toLowerCase()) {
                case "settooltip":
                    if (param0 === "") $("#" + widgetName).tooltip("destroy");
                    else $("#" + widgetName).tooltip({ title: param0, delay: { show: 800 }, placement: "auto top", html: true });
                    break;

                case "display":                                                                                                                     // display or hide widget
                    if (param0 === true) widgetObj.style.setProperty("display", "inline");
                    else widgetObj.style.setProperty("display", "none");
                    break;

                case "getattrib":
                    return widgets[widgetNum].attribs[param0].value;

                case "setattrib":
                    if (widgets[widgetNum].attribs[param0]) widgets[widgetNum].attribs[param0].value = param1;
                    break;

                case "newattrib":
                    widgets[widgetNum].attribs.push(new widgetAttrib(param0, param1, param2));                                                      // Add a new attrib to the widget (eg. for a dynamic channel or state store)
                    break;

                case "subscribe":
                    parent.send("WIDGETS", "INISUB", param0)                                                                                        // resigter the channel on the host
                    widgets[widgetNum].attribs.push(new widgetAttrib("", "channel", param0));                                                       // add channel attrib (blank name = hidden) so that channel messages from host will be sent to widget
                    break;

                case "getchannels":                                                                                                                 // Get all the channels for a server plugin (param0 = category, param1 = class/plugin name
                    return (typeof plugins[param0.toUpperCase() + "/" + param1.toUpperCase()] !== undefined) ? plugins[param0.toUpperCase() + "/" + param1.toUpperCase()].Channels : ""

                case "selectchannels":
                    toggleToolbox("channelToolbox", "open");
                    break;

                case "save":
                    saveScreen();
                    break;

                case "endedit":
                    resetEdit(widgetName);
                    break;

                case "zorder":
                    widgetObj.style.setProperty("z-index", param0);
                    break;

                case "updatestatus":
                    parent.status(param0);
                    break;

                case "servername":
                    return parent.serverName;

                case "history":
                    (function (widgetNum, param0, param1, param2, param3) {
                        histReqs.push({ "widgetNum": widgetNum, "channel": param0, "range": param1 + "," + param2 });                               // Save history request so results can be sent back to widget
                        parent.send("HISTORY", param0, param1 + "," + param2)                                                                       // Get history records for channel (param0) since time (param1) in javascript time
                    })(widgetNum, param0, param1, param2, param3);
                    break;

                case "send":
                    if (param0.split("/").length !== 3) return false;                                                                               // channel must be in the form CATEGORY/classname/instance
                    parent.channelSend(param0.toString(), param1.toString(), param2.toString());
                    for (var widget = 0; widget < widgets.length; widget++) {                                                                       // if other widgets on the screen subscribe to the same channel send message to them as message won't be echoed back
                        if ((widgetNum !== widget) && (widgets[widget].screen === selScreenNum)) {
                            for (var attrib = 0; attrib < widgets[widget].attribs.length; attrib++) {
                                if (widgets[widget].attribs[attrib].type === "channel" && widgets[widget].attribs[attrib].value === param0) widgetAction("widgetObj" + widget, "feed", param0, param1, param2)
                            }
                        }
                    }
                    break;

                case "adjustsize":                                                                                                                  // Adjust parent container for widgets that manage their own shape
                    switch (param0.toLowerCase()) {
                        case "width":
                            widgetObj.style.setProperty("width", param1 + "px")
                            break;
                        case "height":
                            widgetObj.style.setProperty("height", param1 + "px")
                            break;
                        case "topoffset":
                            widgetObj.style.setProperty("top", (parseInt(widgetObj.style.getPropertyValue("top")) + parseInt(param1)) + "px");
                            widgets[widgetNum].locY = parseInt(widgetObj.style.getPropertyValue("top"));
                            break;
                        case "leftoffset":
                            widgetObj.style.setProperty("left", (parseInt(widgetObj.style.getPropertyValue("left")) + parseInt(param1)) + "px");
                            widgets[widgetNum].locX = parseInt(widgetObj.style.getPropertyValue("left"));
                            break;
                        case "scalex":
                            widgets[widgetNum].scaleX = +param1;
                            break;
                        case "scaley":
                            widgets[widgetNum].scaleY = +param1;
                            break;
                        default:
                    }
                    break;

                case "connectlink":
                    if (!editLink.nodeName) {
                        startNewLink(param0, widgetName, param1, param2, param3)
                    } else {
                        endNewLink(param0, widgetName, param1, param2, param3)
                    }
                    break;

                default:
                    return false;                                                                                                                   // invalid function
            }
            return true;
        }

        // Main interface for requests from host to widget. Recursively wait if widget has not finished loading
        function widgetAction(widgetName, func, param0, param1, param2, initAction) {
            var widgetNum = parseInt(widgetName.slice(9));
            if (widgets[widgetNum].loadCnt < WIDGETLOADRETRIES && widgets[widgetNum].type) {                                                        // If not too many retries and widget loaded OK
                var widgetObj = document.getElementById(widgetName);                                                                                // Is widget loaded?
                if (widgetObj) {                                                                                                                    // Not even on the page, ignore message as a new page is loaded
                    if (widgetObj.contentDocument && typeof widgetObj.contentDocument.defaultView.fw === "object") {                                // function may not exist yet if widget is still loading
                        widgets[widgetNum].loadCnt = 0
                        if (!g.design) {                                                                                                            // actions requested from the host: msg.Instance, msg.Scope, msg.Data
                            switch (func) {
                                case "feed":                                                                                                        // channel event updates
                                    widgetObj.contentDocument.defaultView.feed(param0, param1, param2);
                                    break;
                                case "ini":                                                                                                         // initial channel state
                                    if (typeof widgetObj.contentDocument.defaultView.ini === "function") return widgetObj.contentDocument.defaultView.ini(param0, param1, param2);
                                    break;
                                case "msg":                                                                                                         // any general message
                                    if (typeof widgetObj.contentDocument.defaultView.msg === "function") return widgetObj.contentDocument.defaultView.msg(param0, param1, param2);
                                    break;
                                case "history":                                                                                                     // history of message logs in JSON
                                    if (typeof widgetObj.contentDocument.defaultView.history === "function") return widgetObj.contentDocument.defaultView.history(param0, param1, param2);
                                    break;
                                default:
                                    return false;
                            }
                        } else if (typeof widgetObj.contentDocument.defaultView.designAction === "function") return widgetObj.contentDocument.defaultView.designAction(func, param0, param1, param2);
                    } else {
                        widgets[widgetNum].loadCnt += 1;
                        setTimeout(widgetAction, ACTION_RETRY_MSEC, widgetName, func, param0, param1, param2, "retry");                             // Not quite finished loading
                    }
                }
            } else {
                parent.status("WARNING - Widget " + widgetName + " (" + widgets[widgetNum].type + ") can't receive request '" + func + " ' params:" + param0 + ", " + param1 + ", " + param2 + "). Try reloading the page.");
                return false;
            }
            return true;
        }

        ////////////////////////////////////////// Manage flow links

        var editLink = {};
        var links = [];
        var link = function (pathID, inpNodeNum, inpNodeType, inpPin, outNodeNum, outNodeType, outPin, path) {
            this.pathID = pathID;
            this.inpNodeNum = inpNodeNum;                   // HTML node object number
            this.inpNodeType = inpNodeType;                 // TODO: Can put this in the widgets array (not currently present)
            this.inpPin = inpPin;
            this.outNodeNum = outNodeNum;
            this.outNodeType = outNodeType
            this.outPin = outPin;
            this.path = path;
        }

        //TODO: drag node drags path
        function startNewLink(type, nodeName, pinXOffset, pinYOffset, pinNum) {

            editLink.nodeName = nodeName;
            editLink.type = type;
            editLink.pinNum = pinNum;

            editLink.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            editLink.path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            editLink.path.setAttribute("id", "Path" + links.length);
            editLink.path.setAttribute("style", "fill: none; stroke: rgb(51, 122, 183);  stroke-width: 3px;");
            editLink.svg.setAttribute("style", "position: absolute; left: 0px; top: 0px; width:100%; height:100%; z-index:10;");
            editLink.svg.setAttribute("id", "Link" + links.length);
            editLink.svg.appendChild(editLink.path);
            document.getElementById("widgetContainer").appendChild(editLink.svg);

            var node = document.getElementById(nodeName);
            editLink.pinX = +node.style.getPropertyValue("left").replace("px", "") + pinXOffset;                                                             // Align to center of pin
            editLink.pinY = +node.style.getPropertyValue("top").replace("px", "") + pinYOffset;

            editLink.nodeX = editLink.pinX + TBWIDTH;                                                       // compensate for distance between starting pin & end of object so path gets drawn when mouse inside object border
            editLink.nodeY = editLink.pinY;
            editLink.enterNodeX = pinXOffset;
            editLink.enterNodeY = pinYOffset;

            document.addEventListener("mousemove", docMouseDraw);
            document.addEventListener("click", endNewLink);                                               // clicking anywhere on the canvas while still drawing but not over a node pin will cancel the path (use undefined parameters to signal to endNewFlow)

            var myWidgets = document.getElementsByClassName("widget");
            for (var widgetNum = 0; widgetNum < myWidgets.length; widgetNum++) {
                myWidgets[widgetNum].contentDocument.addEventListener("mousemove", nodeMouseDraw);      // Allow mouse events to be handled here when cursor is passing over object
            }

            parent.status("New flow connection link started");
        }

        // Mouse events from the object DOM, save the last cursor position from parent DOM
        function nodeMouseDraw(event) {
            if (editLink.enterNodeX == 0) {
                editLink.enterNodeX = event.clientX;
                editLink.enterNodeY = event.clientY;
            }
            drawNewLink(event.clientX - editLink.enterNodeX, event.clientY - editLink.enterNodeY);
        }

        // Mouse events from parent DOM, store current cursor position for when mouse moves over an object
        function docMouseDraw(event) {
            editLink.nodeX = event.clientX;
            editLink.nodeY = event.clientY;
            editLink.enterNodeX = 0;
            editLink.enterNodeY = 0
            drawNewLink(0, 0);
        }

        // Draw the SVG Path based on mouse position relative to parent DOM and include object offset when over an obkect
        function drawNewLink(posX, posY) {
            var newX = Math.abs(posX + editLink.nodeX - editLink.pinX - TBWIDTH) / 4;                                    // set beizer curve have the 2 control points to be 1/4 the X length of the curve (Y same as start & end points)
            if (editLink.type == "inPin") newX = -newX;
            editLink.cX1 = editLink.pinX + newX;
            editLink.cY1 = editLink.pinY;
            editLink.cX2 = editLink.pinX + newX;            //TODO: Should be from X cursor position
            editLink.path.setAttribute("d", "M" + editLink.pinX + "," + editLink.pinY + " C" + editLink.cX1 + "," + editLink.cY1 + " " + editLink.cX2 + "," + (posY + editLink.nodeY) + " "
                + (posX + editLink.nodeX - TBWIDTH) + "," + (posY + editLink.nodeY));
        }

        // Finalise the link path
        function endNewLink(type, nodeName, pinXOffset, pinYOffset, pinNum) {
            if (typeof nodeName !== "undefined" && type != editLink.type) {                                                            // Only allow connections from inputs to outputs
                var node = document.getElementById(nodeName);
                editLink.path.setAttribute("d", "M" + editLink.pinX + "," + editLink.pinY + " C" + editLink.cX1 + "," + editLink.cY1 + " " + editLink.cX2 + "," + editLink.nodeY + " "
                    + (+node.style.getPropertyValue("left").replace("px", "") + pinXOffset) + "," + (+node.style.getPropertyValue("top").replace("px", "") + pinYOffset))       // Align to center of pin
                editLink.path.style.setProperty("stroke", "#999");

                // Add flow arrow adjusted for flow angles
                var pathLength = editLink.path.getTotalLength();
                var midLink = editLink.path.getPointAtLength(pathLength / 2);
                var pt1 = (editLink.path.getPointAtLength(pathLength / 2 - 5));             // get gradient angle of curve at midway
                var pt2 = (editLink.path.getPointAtLength(pathLength / 2 + 5));
                var arrowPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                arrowPath.setAttribute("d", "M0,0 l0,12 l12,-6 z");
                arrowPath.setAttribute("transform", "translate(" + (midLink.x - 6) + "," + (midLink.y - 6) + ") rotate(" + (Math.atan2((pt2.y - pt1.y), (pt2.x - pt1.x)) * 180 / Math.PI + (editLink.type == "outPin" ? 0 : 180)) + " 6 6)")
                arrowPath.setAttribute("style", "fill: #999");
                arrowPath.setAttribute("id", editLink.svg.id.replace("Link", "Arrow"));
                editLink.svg.appendChild(arrowPath);

                var nodeType = node.contentDocument.getElementById("type").getAttribute("data-default");                                            // FLow node type
                var editNodeType = document.getElementById(editLink.nodeName).contentDocument.getElementById("type").getAttribute("data-default");

                if (editLink.type == "outPin") {                                                                    // Could be connected from input pin to output pin or visa versa
                    links.push(new link(editLink.path.id, nodeName.replace("widgetObj", ""), nodeType, pinNum, editLink.nodeName.replace("widgetObj", ""), editNodeType, editLink.pinNum, editLink.path.getAttribute("d")));
                } else {
                    links.push(new link(editLink.path.id, editLink.nodeName.replace("widgetObj", ""), editNodeType, editLink.pinNum, nodeName, nodeType, pinNum, editLink.path.getAttribute("d")));
                }

                editLink.path.addEventListener("click", linkSelected)
                parent.status("New flow connection link created");

            } else {
                editLink.svg.parentNode.removeChild(editLink.svg);
                parent.status("Flow connection link invalid");
            }

            document.removeEventListener("mousemove", docMouseDraw);
            document.removeEventListener("click", endNewLink);
            var myWidgets = document.getElementsByClassName("widget");
            for (var widgetNum = 0; widgetNum < myWidgets.length; widgetNum++) {
                myWidgets[widgetNum].contentDocument.removeEventListener("mousemove", nodeMouseDraw);      // Allow mouse events to be handled when cursor is passing over object
            }
            editLink = {};
        }

        // Link selected by clicking it
        function linkSelected(event) {
            var selLink = event.currentTarget;
            if (selLink.style.getPropertyValue("stroke") === "#999") {
                selLink.style.setProperty("stroke", "rgb(51, 122, 183)");
                editLink.svg = selLink.parentNode;                                          // Need SVG not PATH
                document.addEventListener("keydown", delLink, true);                       // capture delete
            } else {
                event.currentTarget.style.setProperty("stroke", "#999");
                editLink = {};
                document.removeEventListener("keydown", delLink, true);
            }
        }

        // When link is selected and DEL pressed, delete selected link
        //TODO: When node is deleted, need to delete links
        function delLink(e) {
            if (e.keyCode == 46 && editLink.svg) {
                editLink.svg.parentNode.removeChild(editLink.svg);
                links.splice(+editLink.svg.getAttribute("id").replace("Link", ""), 1);
                document.removeEventListener("keydown", delLink, true);
                editLink = {};
            }
        }

        ///////////////////////////////// Utilities

        // Handle callbacks from the modal option selected
        function modalCallback(modalFunction, param1, param2, param3, param4) {
            if (window[modalFunction] !== undefined) window[modalFunction](param1, param2, param3, param4)
        }

        // Callback for setting up new device
        function newDevice() {
            parent.adjustNavBar("Design");
            newScreen();
        }

        // JQuery/BS JS used for modal and tooltips, load late
    </script>
    <script defer src="js/jquery-3.1.0.slim.min.js"></script>
    <script defer src="js/bootstrap.min.js"></script>
</body>
</html>
