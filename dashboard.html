<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Home Automation Client</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <link rel="stylesheet" href="css/bootstrap.min.css" />
    <link rel="stylesheet" href="css/icons.css" />
    <link rel="stylesheet" href="css/style.css" />
</head>
<body id="mainBody" oncontextmenu="return false;" draggable="false" ondragstart="return false;" ondrop="return false;">
    <div id="iconToolbox" class="toolbox">
        <h4 onclick="toggleToolbox('iconToolbox', 'close')">Icons<button type="button" class="close">&times;&nbsp;&nbsp;</button></h4>
        <form class="form-inline" role="form" onsubmit="loadIcons(); return false;">
            <div class="form-group">
                <div class="col-md-11 input-group toolboxControls">
                    <input type="text" id="iconSearchTxt" class="form-control input-sm" placeholder="search" />
                    <button type="submit" class="input-group-addon pointer"><i class="icon-search"></i></button>
                </div>
            </div>
        </form>
        <div id="iconToolboxScroll" onclick="iconSel(event)"></div>
    </div>
    <div id="widgetToolbox" class="toolbox" align="center">
        <h4 onclick="toggleToolbox('widgetToolbox', 'close')">Widgets<button type="button" class="close">&times;&nbsp;&nbsp;</button></h4>
        <form class="form-inline" role="form" onsubmit="filterWidgets(); return false;">
            <div class="form-group">
                <div class="col-md-11 input-group toolboxControls">
                    <input type="text" id="widgetSearchTxt" class="form-control input-sm" placeholder="search" />
                    <button type="submit" class="input-group-addon pointer"><i class="icon-search"></i></button>
                </div>
            </div>
        </form><br />
        <div id="widgetToolboxScroll" onclick="iconSel(event)"></div>
    </div>
    <div id="channelToolbox" class="toolbox">
        <h4 onclick="toggleToolbox('channelToolbox', 'close')">Channels<button type="button" class="close">&times;&nbsp;&nbsp;</button></h4>
        <form class="form-inline" role="form" onsubmit="filterChannels(); return false;">
            <div class="form-group">
                <div class="col-md-11 input-group toolboxControls">
                    <input type="text" id="channelSearchTxt" class="form-control input-sm" placeholder="search" />
                    <button type="submit" class="input-group-addon pointer"><i class="icon-search"></i></button>
                </div>
            </div>
        </form><br />
        <div class="col-lg-11 input-group toolboxControls">
            <button type="button" id="noChannel" onclick="channelSel(event)" class="btn btn-default btn-block">None</button><br />
        </div>
        <div id="channelToolboxScroll" onclick="channelSel(event)" style="top: 150px"></div>
    </div>
    <div class="sidebar" id="sidebar">
        <div class="tabs-left">
            <h4>&nbsp;&nbsp;&nbsp;Screens</h4>
            <h6>&nbsp;</h6>
            <ul id="sidebarList" class="nav nav-tabs"></ul>
            <div id="sideScreenEditor" style="display: none; position: absolute; bottom: 2px; left: 15px;">
                <p class="nav-header">Design Options</p>
                <a class="tip icon nounderline pointer" data-original-title="Add" data-placement="top" onclick="newScreen()"><i class="icon-new-tab icon-large">&nbsp;</i></a>
                <a class="tip icon nounderline pointer" data-original-title="Delete" data-placement="top" onclick="deleteScreen()"><i class="icon-remove-2 icon-large">&nbsp;</i></a>
                <a class="tip icon nounderline pointer" data-original-title="Save" data-placement="top" onclick="saveScreen()"><i class="icon-save icon-large">&nbsp;</i></a>
                <a class="tip icon nounderline pointer" data-original-title="Widgets" data-placement="top" onclick="toggleToolbox('widgetToolbox', '')"><i class="icon-dashboard icon-large">&nbsp;</i></a>
            </div>
        </div>
    </div>
    <div class="topbar" id="topbar">
        <ul id="topbarList" class="nav nav-tabs"></ul>
    </div>
    <div class="content">
        <div id="widgetSection" class="widgetCanvas">
            <!-- Main container -->
            <div id="widgetOptionMenu" class="dropdown" style="display: none; position: absolute">
                <!-- options for widgets -->
                <ul id="widgetOptionList" class="dropdown-menu" role="menu" style="display: inline;">
                    <li id="widgetOptionMenuDivider" class="divider"></li>
                    <li><a tabindex="-1"><input type="checkbox" id="zorder" data-type="zorder" />&nbsp;On Top</a></li>
                    <li><a tabindex="-1" onclick="helpWidget()">Help</a></li>
                    <li><a tabindex="-1" onclick="parent.modalDialog('text', 'Delete Widget', 'Confirm that you want to delete ' + widgets[editData.widgetNum].type + '?','Delete', 'deleteWidget', editData.widgetNum)">Delete</a></li>
                    <li><a tabindex="-1" onclick="closeWidgetMenu('cancel')">Cancel</a></li>
                    <li><a tabindex="-1" onclick="closeWidgetMenu('save')">Close</a></li>
                </ul>
            </div>
            <div id="widgetContainer" style="position: absolute; left:0px; z-index: 0; height: 100%; width: 100%" onclick="canvasClick()">
                <canvas id="cvsDesign" style="display:none; z-index: 1; height: inherit; width: inherit"></canvas>
                <div id="widgetsDiv"></div>
                <div id="fade" style="display: inline; position: absolute; left:0px; height: 100%; width: 100%; opacity:0.5; background-color: white; z-index: 200"></div>
            </div>
        </div>
    </div>

    <script>
        "use strict";

        parent.profiler("dashloaded")

        var screens = [];
        var myScreen = function (name, icon) {
            this.name = name;
            this.icon = icon;
        }

        var channels = [];
        var channel = function (category, className, name, desc, type, IO, min, max, units) {
            this.category = category;
            this.className = className;
            this.name = name;
            this.desc = desc;
            this.type = type;
            this.IO = IO;
            this.min = min;
            this.max = max;
            this.units = units;
        }

        var widgets = [];
        var widget = function (type, ext, screen, locX, locY) {
            this.type = type;
            this.ext = ext;
            this.locX = locX;
            this.locY = locY;
            this.scaleX = 1;
            this.scaleY = 1;
            this.iniWidth = null;
            this.iniHeight = null;
            this.screen = screen;
            this.zOrder = 10;
            this.attribs = [];
            this.iniMsg = [];
            this.loadCnt = 0;
        };

        var plugins = [];
        var TBwidgets = [];
        var histReqs = [];

        // Generic property structure for widgets
        var widgetAttrib = function (name, type, value) {
            this.name = name;
            this.type = type;
            this.value = value;
        }

        var GRABSIZE = 8;                                                           // size of the grab rectangle block in design mode
        var DESIGNGRID = 10;                                                        // grid size in design mode
        var TBWIDGETWIDTH = 100;                                                    // width of the objects in the toolbox
        var WIDGETLOADRETRIES = 200;                                                // number of retries waiting for widget to load
        var ACTION_RETRY_MSEC = 0;                                                  // How long to retry waiting for widget
        var TBWIDTH = document.getElementById("widgetSection").offsetLeft;          // size of sidebar

        var widgetMax = { width: 1280, height: 900 };                               // maximum screen size for all screens used for UWP client
        var selScreenNum = 0;                                                       // selected screen
        var barList;                                                                // top or side lists
        var widgetToLoadCnt, widgetLoadedCnt;                                       // Counter for when the last widget has finished loading.
        var widgetSubscribe = "";                                                   // list of subscriptions
        var toolboxParam;                                                           // Save the toolbox parameter for other functions
        var tabIconSelected = "";                                                   // Save the name of the icon selected for saving

        var g = {}                                                                  // used for global boolean flags
        g.design = false                                                            // design mode flag
        g.loadedTB = false;                                                         // toolbox already loaded
        g.dirty = false;                                                            // changed without saving
        g.menuOpen = false;                                                         // widget edit menu state

        var editData = {};                                                          // Global object for tracking edit state
        var dragData = {};                                                          // Global object for tracking dragging state

        document.addEventListener("keydown", keyPress, true);                       // capture keypresses

        // API object injected into widgets for interaction with framework
        var widgetAPI = function (widgetName) {
            this.widgetName = widgetName;
            this.widgetNum = parseInt(widgetName.replace("widgetObj", "").replace("TB", ""));
            this.widgetID = document.getElementById(widgetName).contentDocument.getElementById("widget");                                           // widget element in the widget object

            this.state = "dashboard";
            if (widgetName.indexOf("TB") !== -1) this.state = "toolbox";
            else {
                this.attribs = widgets[this.widgetNum].attribs;
                this.scaleX = widgets[this.widgetNum].scaleX;
                this.scaleY = widgets[this.widgetNum].scaleY;
                this.iniHeight = widgets[this.widgetNum].iniHeight;
                this.iniWidth = widgets[this.widgetNum].iniWidth;
                if (g.design) this.state = "design";
            }

            // Access general framework functions from dashboard
            this.func = function (funcName, param0, param1, param2) {
                var result = widgetRequest(widgetName, funcName, param0, param1, param2);
                if (this.widgetName.substr(0, 11) !== "widgetObjTB") this.attribs = widgets[this.widgetNum].attribs;                                // reload attributes in case attribs are updated
                return result;
            }

            // send channel data to the host
            this.channelSend = function (channel, scope, data) {
                return widgetRequest(widgetName, "send", channel, scope, data);
            }
        }

        if (parent.deviceWidth < 1025) {                                                                                                            // Adjust screen based on width
            document.getElementById("sidebar").style["display"] = "none";
            document.getElementById("topbar").style["display"] = "inline";
            document.getElementById("widgetSection").className = "widgetCanvasMobile";
            barList = "topbarList";
        } else {
            document.getElementById("sidebar").style["display"] = "inline";
            document.getElementById("topbar").style["display"] = "none";
            barList = "sidebarList";
        }

        //////////////////////////////////////////// Widget design menu

        // Display modal with HTML help text for a widget being edited
        function helpWidget() {
            var widgetHelp = "No help found.";
            if (typeof editData.widgetView.help === "function") widgetHelp = editData.widgetView.help(); 
            parent.modalDialog("text", "Help for " + widgets[editData.widgetNum].type + " widget", widgetHelp);                                     // Display help string returned from help function in widget
        }

        // Display the widget menu based on the attributes available
        function showWidgetMenu(widgetName) {
            var widgetProp;
            var docFrag = document.createDocumentFragment();
            var menuItem = document.createElement("li")
            var menu = document.getElementById("widgetOptionMenu");
            var list = document.getElementById("widgetOptionList");
            var divider = document.getElementById("widgetOptionMenuDivider");
            var dropSel = [];
            var channelNum = 0;

            setEdit(widgetName);                                                                                                                    // turn on editing
            g.menuOpen = true;

            while (list.firstChild !== divider) list.removeChild(list.firstChild);                                                                  // clear list up to the divider
            menuItem.innerHTML = "<h5 class='text-center'><b>Configure Widget</b></h5>";
            docFrag.appendChild(menuItem)

            for (var i = 0; i < widgets[editData.widgetNum].attribs.length; i++) {
                menuItem = document.createElement("li")
                widgetProp = widgets[editData.widgetNum].attribs[i].name;
                var innerHTML = "";

                switch (widgets[editData.widgetNum].attribs[i].type) {                                                                              // build the widget property menu based on attributes for the widget
                    case "dropdown":
                        var options = widgetProp.split(",")                                                                                         // options separated by commas
                        var selectName = "select" + dropSel.length                                                                                  // create an array in case there are multiple dropdowns
                        innerHTML = "<a tabindex='-1' href='#'><select id='" + selectName + "' data-type='dropdown' class='span2'>"
                        for (var j = 0; j < options.length; j++) {
                            innerHTML += "<option>" + options[j].trim() + "</option>";
                            if (options[j].trim() === widgets[editData.widgetNum].attribs[i].value) dropSel.push(j);
                        }
                        innerHTML += "</select></a>";
                        break;
                    case "checkbox":
                        var checked = "";
                        if (widgets[editData.widgetNum].attribs[i].value === true) checked = "checked";
                        innerHTML = "<a tabindex='-1' href='#'><label class='checkbox'><input type='checkbox' " + checked + " data-type='checkbox' />" + widgetProp + "</label></a>";
                        break;
                    case "channel":                                                                                                                 // if the channel name is blank, don't display it (hidden channel)
                        var chName = widgets[editData.widgetNum].attribs[i].value;
                        if (chName === "") chName = "none";
                        if (widgetProp !== "") innerHTML = "<a tabindex='-1' id='channelItem" + channelNum + "' href='#' data-selected='" + widgets[editData.widgetNum].attribs[i].value + "' data-type='channel' onclick='toggleToolbox(\"channelToolbox\", \"open\", " + channelNum + ")'>" + widgetProp + ": " + chName + "</a>";
                        channelNum = channelNum + 1;
                        break;
                    case "file":
                        innerHTML = "<a tabindex='-1' id='menuFile' href='#'>" + widgets[editData.widgetNum].attribs[i].value + "&nbsp;&nbsp<input id='selectedFile' type='file' accept='image/jpeg,image/png,image/gif' size='1' data-type='file' style='display: none'/><button onclick='fileInputHelper()'>File</button></a>";
                        break;
                    case "input":
                        innerHTML = "<a tabindex='-1' href='#'>" + widgets[editData.widgetNum].attribs[i].name + "&nbsp;&nbsp;<input type='text' class='form-control input-sm' value='" + widgets[editData.widgetNum].attribs[i].value + "' data-type='input' placeholder='" + widgets[editData.widgetNum].attribs[i].value + "'></a>";
                        break;
                    case "data":                                                                                                                    // store widget variables (hidden on option menu)
                        innerHTML = "<a data-type='data' style='display: none;'>" + widgets[editData.widgetNum].attribs[i].value + "</a>";
                        break;
                    default:
                }
                menuItem.innerHTML = innerHTML;
                docFrag.appendChild(menuItem);
            }

            list.insertBefore(docFrag, divider);

            for (var i = 0; i < dropSel.length; i++) {                                                                                              // set the default setting for each dropdown in the menu
                document.getElementById("select" + i).selectedIndex = dropSel[i];
            }

            menu.style.setProperty("display", "inline");

            if (widgets[editData.widgetNum].zOrder === 100) document.getElementById("zorder").checked = true;
            else document.getElementById("zorder").checked = false;

            menu.style.setProperty("left", parseInt(editData.widgetObj.offsetLeft) + ((parseInt(editData.widgetObj.offsetLeft) < window.innerWidth / 2) ? (parseInt(editData.widgetObj.width) + 5) : (-1 * (list.clientWidth))) + "px");
            menu.style.setProperty("top", parseInt(editData.widgetObj.offsetTop) + (((parseInt(editData.widgetObj.offsetTop) >= window.innerHeight / 2) ? (-1 * (list.clientHeight)) : 0)) + "px");  // adjust menu position based on location of widget so menu stays on the screen
        }

        // Helper for menu to select files. click the hidden file input tag and display selected file
        function fileInputHelper() {
            document.getElementById("selectedFile").click();
            document.getElementById("menuFile").innerHTML = document.getElementById("selectedFile").files[0].name + "&nbsp;&nbsp<input id='selectedFile' type='file' accept='image/*' size='1' data-type='file' style='display: none'/><button onclick='fileInputHelper()'>File</button>"
            document.getElementById("selectedFile").files[0] = document.getElementById("selectedFile").files[0]                                    // re-attach the selected file to the element as it gets destroyed when replacing the HTML
        }

        function closeWidgetMenu(option) {
            if (option === "save") {
                walkList(document.getElementById("widgetOptionList"), 0);                                                                           // recursive save all the menu settings based on nodes with widget data-type attribute
                if (typeof editData.widgetView.menuUpdate === "function") editData.widgetView.menuUpdate();                                         // call menu update routine in widget
            }
            if (option === "cancel") parent.status("Changes to widget '" + widgets[editData.widgetNum].type + "' cancelled.");
            if (option === "save") resetEdit(editData.widgetName);
            document.getElementById("widgetOptionMenu").style.setProperty("display", "none");                                                       // hide option menu
            g.menuOpen = false;
        }

        // Save widget attribute data based on the values set in the widget option menu
        function walkList(node, optionCnt) {
            var children = node.childNodes;
            for (var i = 0; i < children.length; i++) optionCnt = walkList(children[i], optionCnt);                                                 // recursive find lowest sibling
            if (node.attributes && node.attributes["data-type"]) {
                switch (node.attributes["data-type"].nodeValue) {                                                                                   // build the widget property menu based on attributes for the widget
                    case "zorder":
                        if (node.checked) widgets[editData.widgetNum].zOrder = 100;
                        else widgets[editData.widgetNum].zOrder = 10;
                        editData.widgetObj.style.setProperty("z-index", widgets[editData.widgetNum].zOrder);
                        break;
                    case "checkbox":
                        widgets[editData.widgetNum].attribs[optionCnt].value = node.checked;
                        break;
                    case "channel":
                        widgets[editData.widgetNum].attribs[optionCnt].value = node.getAttribute("data-selected");
                        break;
                    case "dropdown":
                        widgets[editData.widgetNum].attribs[optionCnt].value = node.value.trim().toLowerCase();
                        break;
                    case "file":
                        if (typeof node.files[0] !== "undefined") {
                            var oFReader = new FileReader();
                            //var widgetNum = editData.widgetNum                                                      // editData gets destroyed before onload runs ?????????????????????????????????????????????
                            oFReader.onload = function (oFREvent) {
                                if (oFREvent.target.result.toString().length > 139999) {
                                    alert("ERROR: File Size of " + parseInt(oFREvent.target.result.toString().length * 0.00074) + "K Bytes for image file '" + node.files[0].name + "' is too large. Select an image of size less than 100K Bytes instead.");
                                } else {
                                    parent.send("WIDGETS", "FILE", "IMAGE," + editData.widgetNum + "," + node.files[0].name + "," + oFREvent.target.result)
                                }
                            };
                            oFReader.readAsDataURL(node.files[0]);                                                                                  // Read in as base64
                            widgets[editData.widgetNum].attribs[optionCnt].value = node.files[0].name
                        }
                        break;
                    case "input":
                        widgets[editData.widgetNum].attribs[optionCnt].value = node.value;
                        break;
                    case "data":
                        widgets[editData.widgetNum].attribs[optionCnt].value = node.innerHTML;
                        break;
                    default:
                }
                optionCnt += 1;
                g.dirty = true;
            }
            return optionCnt;
        }

        // Delete widget and reset edit mode
        function deleteWidget() {
            if (editData.widgetName) {
                parent.status("Deleted widget #" + editData.widgetNum + " (" + widgets[editData.widgetNum].type + ")");
                g.dirty = true;
                widgets.splice(editData.widgetNum, 1)                                                                                               // remove widget from widget array
                closeWidgetMenu("deleted");
                editData.widgetObj.parentNode.removeChild(editData.widgetObj);                                                                      // remove widget
                editData = {};
            }
        }

        //////////////////////////////////////////// Design mode

        // Setup design
        function setDesign() {
            if (!g.design) {
                if (g.loadedTB === false) {                                                                                                         // Initialise for the design environment (only run once)
                    parent.send("WIDGETS", "TOOLBOX", "");                                                                                          // retrieve the available toolbox widget names from server
                    drawlines(parent.deviceWidth, parent.deviceHeight);
                    setTimeout(loadIcons, 50);
                    g.loadedTB = true;
                }
                g.design = true;
                parent.status("Designer Mode");
                document.getElementById("cvsDesign").style.setProperty("display", "inline");
                document.getElementById("sideScreenEditor").style.setProperty("display", "inline");
                document.body.setAttribute("spellcheck", "true");
                var nodes = document.getElementById(barList).getElementsByTagName("span");
                for (var i = 0; i < nodes.length; i++) nodes[i].setAttribute("contenteditable", "true");                                            // Able to edit span text
                var allWidgets = document.querySelectorAll(".widget");
                for (var i = 0; i < allWidgets.length; i++) {                                                                                       // Loop through all widgets on screen and run the startdesign routine in the widget
                    if (typeof allWidgets[i].contentDocument.defaultView.startDesign === "function") allWidgets[i].contentDocument.defaultView.startDesign();
                    allWidgets[i].contentDocument.defaultView.fw.state = "design";
                }
            }
        }

        // Load widget toolbox with just the filtered widgets
        function filterWidgets() {
            document.getElementById("widgetToolboxScroll").innerHTML = "";                                                                          // clear toolbox
            var TBWidgetNames = ""
            for (var TBWidgetNum = 0; TBWidgetNum < TBwidgets.length; TBWidgetNum++) TBWidgetNames = TBWidgetNames + TBwidgets[TBWidgetNum].type + ".html,";
            initTBWidgets(TBWidgetNames.slice(0, -1), document.getElementById("widgetSearchTxt").value.trim());
        }

        // Load channel toolbox with just filtered channels
        function filterChannels() {
            loadChannels(document.getElementById("channelSearchTxt").value.trim(), false)
        }

        // Load icon toolbox with just filtered icons
        function loadIcons() {
            var filter = document.getElementById("iconSearchTxt").value;
            document.getElementById("iconToolboxScroll").innerHTML = "";                                                                            // Clear toolbox
            var docFrag = document.createDocumentFragment();                                                                                        // load icons into icon toolbox
            for (var sheet = 0; sheet < document.styleSheets.length; sheet++) {
                if (document.styleSheets[sheet].href.indexOf("icons.css") !== -1) {                                                                 // Only look in icons stylesheet
                    var cssRules = document.styleSheets[sheet].cssRules;
                    for (var rule = 0; rule < cssRules.length; rule++) {                                                                            // check all CSS rules
                        var selectorText = cssRules[rule].selectorText;
                        if (selectorText && (selectorText.indexOf(":before") !== -1)) {                                                             // Only process the icons (icomoon uses :before in the icon string)
                            if (selectorText.toLowerCase().indexOf(filter.toLowerCase()) !== -1) {                                                  // Apply any filter specified to narrow down list
                                var iconElement = document.createElement("li");
                                var iconbits = selectorText.split(":")
                                iconElement.innerHTML = "<i style='cursor: pointer' id='" + iconbits[0].slice(1) + "' class='" + iconbits[0].slice(1) + " icon-large'></i><br/>" + iconbits[0].slice(6) + "<br/>" + "<br/>"
                                docFrag.appendChild(iconElement);
                            }
                        }
                    }
                    break;
                }
            }
            document.getElementById("iconToolboxScroll").appendChild(docFrag);
        }

        // Gridlines in the background canvas for design mode
        function drawlines(width, height) {
            var cvs = document.getElementById("cvsDesign");
            var canvas_ctx = cvs.getContext("2d");
            var maxWidth = parent.iFrame.clientWidth;
            var maxHeight = parent.iFrame.clientHeight;
            cvs.width = maxWidth;
            cvs.height = maxHeight;
            if (typeof width !== "undefined") maxWidth = width;                                                                                     // if width defined for phone
            if (typeof height !== "undefined") maxHeight = height;
            canvas_ctx.lineWidth = 1;
            var cnt = 3;
            for (var x = 1; x < maxWidth; x = x + DESIGNGRID) {
                if (cnt === 3) {
                    canvas_ctx.strokeStyle = "rgb(207, 221, 232)";
                    cnt = -1;
                }
                canvas_ctx.beginPath();
                canvas_ctx.moveTo(x - 0.5, 0.5);
                canvas_ctx.lineTo(x - 0.5, maxHeight - 0.5);
                canvas_ctx.stroke();
                cnt = cnt + 1;
                if (cnt === 0) canvas_ctx.strokeStyle = "rgb(221, 235, 246)";
            }
            var cnt = 3;
            for (var y = 1; y < maxHeight; y = y + DESIGNGRID) {
                if (cnt === 3) {
                    canvas_ctx.strokeStyle = "rgb(207, 221, 232)";
                    cnt = -1;
                }
                canvas_ctx.beginPath();
                canvas_ctx.moveTo(0.5, y - 0.5);
                canvas_ctx.lineTo(maxWidth - 0.5, y - 0.5);
                canvas_ctx.stroke();
                cnt = cnt + 1;
                if (cnt === 0) canvas_ctx.strokeStyle = "rgb(221, 235, 246)";
            }
        }

        // Open and close toolbox
        function toggleToolbox(toolboxName, openclose, param) {
            toolboxParam = param;
            if (document.getElementById(toolboxName).style.getPropertyValue("left") !== "0px") {
                if (openclose === "open" || openclose === "") document.getElementById(toolboxName).style.setProperty("left", "0px");
            } else {
                if ((openclose === "close" || openclose === "")) document.getElementById(toolboxName).style.setProperty("left", "-200px");
            }
            parent.status("");
        }

        //////////////////////////////////////////// Screens

        // Populate the screen object from initial connection data
        function initScreens(screenJSON) {
            if (screenJSON !== "") {
                screens = JSON.parse(screenJSON);
                for (var screen = 0; screen < screens.length; screen++) createTab(screen, false);
            } else {
                if (parent.deviceWidth < 1025) parent.modalDialog("text", "First use", "Welcome to the home automation client. <br><br>As this is a small screen not ideal for designing screens, go to a desktop and impersonate the name of this device to setup its screens.", "Continue", "")
                else parent.modalDialog("text", "First use", "Welcome to the home automation client. <br><br>To get started, rename the 'New Screen' tab and use the Design Options icons on the bottom left corner to create or delete screens, save or use the widget toolbox to drag and add widgets. <br><br>Press the 'Help' button in the navigation bar and select 'Starting' for more instructions.", "Continue", "newDevice");
            }
        }

        function deleteScreen() {
            parent.modalDialog("text", "Delete Screen", "Confirm deletion of screen '" + screens[selScreenNum].name + "'.", "Delete", "removeScreen", selScreenNum);
        }

        // Callback from delete screen modal
        function removeScreen(screenNum) {
            var bar = document.getElementById(barList);                                                                             // parent
            screens.splice(screenNum, 1);                                                                                           // remove screen from array
            for (var widget = 0; widget < widgets.length; widget++) {                                                                                         // remove all widgets on that screen
                if (widgets[widget].screen === screenNum) widgets.splice(widget, 1);
            }
            bar.removeChild(document.getElementById("ScreenLi-" + screenNum));
            if (bar.childElementCount > 0) {
                bar.firstElementChild.className = "active";                                                                         // make the first element active
                selScreenNum = parseInt(bar.firstElementChild.id.split("-")[1]);
            }
            populateScreenWidgets();
        }

        // create a new screen tab
        function newScreen() {
            screens.push(new myScreen("New Screen", "icon-exclamation-sign"));
            var liNum = createTab(screens.length - 1, true);
            selScreenNum = screens.length - 1;
            selectedTab(liNum);
            var range = document.createRange();                                                                                     // set edit cursor to new tab
            var sel = window.getSelection();
            range.setStart(document.getElementById("screenTab-" + liNum).childNodes[1], 0);
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);
            parent.status("New screen created");
        }

        // create a tab screen
        function createTab(screenNum, edit) {
            var num = document.getElementById(barList).childElementCount;
            var iconElement = document.createElement("li");
            iconElement.id = "ScreenLi-" + num;
            iconElement.innerHTML = "<a tag='screenTab' data-toggle='tab' onclick='screenTabClick(this)' id='screenTab-" + num + "' style='cursor: pointer'><i onclick='tabIconClick(this)' class='" + screens[screenNum].icon + " icon-large'></i><span onblur='saveScreenText(this)' contenteditable='" + edit + "'>" + screens[screenNum].name + "</span></a>"
            document.getElementById(barList).appendChild(iconElement);
            return num;
        }

        // Load widgets onto screen
        function populateScreenWidgets(stopReload) {
            if (widgets.length > 0) {
                widgetToLoadCnt = 0;
                widgetLoadedCnt = 0;

                if (!stopReload) {
                    document.getElementById("fade").style.setProperty("display", "inline");                                         // move offscreen to make for clean rendering
                    setTimeout(populateScreenWidgets, 0, true);                                                                     // Fade the screen by rendering
                    return;
                }

                parent.profiler("startscreenload")

                var container = document.getElementById("widgetContainer");
                var newDiv = document.createElement("div");
                container.style.setProperty("left", "-5000px");                                    // move offscreen to make for clean rendering
                widgetSubscribe = "";

                for (var item = 0; item < widgets.length; item++) {
                    if ((widgets[item].screen === selScreenNum)) {
                        loadWidget(newDiv, item);                                                                                   // Load new widget to our new element
                        widgetToLoadCnt += 1;
                        for (var i = 0; i < widgets[item].attribs.length; i++) {                                                    // cache channel to subscribe to
                            if (widgets[item].attribs[i].type === "channel" && widgets[item].attribs[i].value !== "") {             // don't duplicate subscription
                                if (widgetSubscribe.indexOf(widgets[item].attribs[i].value) === -1) widgetSubscribe = widgetSubscribe + widgets[item].attribs[i].value + ",";
                            }
                        }
                    }
                }

                newDiv.id = "widgetsDiv"
                container.replaceChild(newDiv, container.childNodes[3]);
                newDiv = null;                                                                                                      // Garbage collect

                if (widgetSubscribe !== "") {
                    widgetSubscribe = widgetSubscribe.slice(0, -1);                                                                 // remove trailing comma & subscribe
                    parent.send("WIDGETS", "INISUB", widgetSubscribe);
                }
                parent.profiler("endscreenload")
            }
        }

        // Save the contents of an edited sidebar tab
        function saveScreenText(me) {
            screens[me.parentNode.id.split("-")[1]].name = me.innerText;                                                            // index is found in the parent ID after the '-'
        }

        function saveScreen() {
            if (editData.widgetName) resetEdit(editData.widgetName);                                                                // turn off editing for any widget being edited
            if (screens.length !== 0) {
                for (var i = 0; i < screens.length; i++) {
                    if (screens[i].name === "New Screen") {
                        alert("Error, screen not saved - A screen has not been given a name, rename 'New Screen' to something else before saving.");
                        return;
                    }
                    for (j = 0; j < widgets.length; j++) {
                        if (widgets[j].screen === screens[i].name) break;
                    }
                    if (j === widgets.length) {
                        alert("Error, screen not saved - Screen '" + screens[i].name + "' does not have widgets. Open toolbox and drag a widget to the screen before saving.");
                        return;
                    }
                }
                g.dirty = false;
                parent.status("Screens saved.");
                parent.send("SCREENS", "SAVE", JSON.stringify(screens));
                var saveWidgets = [];                                                                                               // compress widgets to save bandwidth/speed
                for (var i = 0; i < widgets.length; i++) {
                    var widgetAttribs = [];
                    for (var y = 0; y < widgets[i].attribs.length; y++) widgetAttribs.push({ n: widgets[i].attribs[y].name, t: widgets[i].attribs[y].type, v: widgets[i].attribs[y].value });
                    saveWidgets.push({ t: widgets[i].type, e: widgets[i].ext, lX: widgets[i].locX, lY: widgets[i].locY, sX: (+widgets[i].scaleX).toFixed(2), sY: (+widgets[i].scaleY).toFixed(2), w: widgets[i].iniWidth, h: widgets[i].iniHeight, s: widgets[i].screen, d: widgets[i].device, z: widgets[i].zOrder, a: widgetAttribs })
                }
                parent.send("WIDGETS", "SAVE", JSON.stringify(saveWidgets));
            } else {
                alert("Error, screen not saved - Create a screen first before saving by pressing the 'add' icon.")
            }
        }

        // selected a new screen tab
        function screenTabClick(e) {
            if ("screenTab-" + selScreenNum !== e.id) {                                                                              // Dont reload currently selected screen
                selectedTab(parseInt(e.id.split("-")[1]));
            }
        }

        // selected a new screen tab via tab icon (allows us to change icons when editing screens)
        function tabIconClick(e) {
            selScreenNum = parseInt(e.parentNode.id.split("-")[1]);
            selectedTab(selScreenNum);
            if (g.design) {
                tabIconSelected = e.parentNode.id;
                toggleToolbox("iconToolbox", "open");
            }
        }

        // change the screen based on tab clicked
        function selectedTab(newScreenNum, firstLoad) {
            if (screens.length > 0) {
                document.getElementById(barList).childNodes[selScreenNum].className = "pointer";                                    // make existing selected element not active
                endWidgetSess();
                parent.status("Loading new screen...");
                selScreenNum = newScreenNum;                                                                                        // set global for functions setting new tab active
                document.getElementById(barList).childNodes[newScreenNum].className = "active";                                     // make the selected element active
                populateScreenWidgets(firstLoad);
            }
        }

        // End widget sessions
        function endWidgetSess() {
            if (widgetSubscribe !== "") parent.send("WIDGETS", "UNSUB", widgetSubscribe);                                   // TODO @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
            //var screenWidgets = document.querySelectorAll(".widget");
            //for (var widgetNum = 0; widgetNum < screenWidgets.length; widgetNum++) {                                                // Run any end session functions in widgets
            //    if (!g.design && typeof screenWidgets[widgetNum].contentDocument.defaultView.endSession === "function") screenWidgets[widgetNum].contentDocument.defaultView.endSession()
            //}
        }

        // callback when an icon in the icontoolbox is selected
        function iconSel(event) {
            if (event.target.id !== "") {                                                                                           // only select the event of the icon (other closeby elements dont have an id
                if (tabIconSelected !== "") {
                    document.getElementById(tabIconSelected).getElementsByTagName("i")[0].className = event.target.id + " icon-large";
                    toggleToolbox("iconToolbox", "close");
                    screens[selScreenNum].icon = event.target.id
                    tabIconSelected = "";
                }
            }
        }

        //////////////////////////////////////////// Channels
        //TODO: Only show channels that match the attributes of the widget (eg. input only)
        function channelSel(event) {                                                                                                // category, class and instance names stored in ID as category\class\channel
            if (event.target.id !== "" && toolboxParam) {                                                                           // only select the event of the icon selected (other close by elements dont have an id)
                var channelItem = document.getElementById("channelItem" + toolboxParam);
                if (event.target.id === "noChannel") {
                    channelItem.setAttribute("data-selected", "");
                    channelItem.innerText = channelItem.innerText.split(":")[0].trim() + ": "
                } else {
                    channelItem.setAttribute("data-selected", event.target.id);        // save in element data
                    channelItem.innerText = channelItem.innerText.split(":")[0].trim() + ": " + event.target.id.split("/")[2] + " (" + event.target.id.split("/")[1] + ")"
                }
                toggleToolbox("channelToolbox", "close");
            }
        }

        // Load the channel toolbox
        function loadChannels(filter, start) {
            var ChContainer = document.getElementById("channelToolboxScroll");
            while (ChContainer.lastChild) ChContainer.removeChild(ChContainer.lastChild);                                           // clear the channel container

            for (var plugin in plugins) {
                for (var item = 0; item < plugins[plugin].Channels.length; item++) {
                    if (plugins[plugin].Channels[item].Name.toLowerCase().trim().indexOf(filter.toLowerCase().trim()) !== -1 ||
                        plugins[plugin].ClassName.toLowerCase().trim().indexOf(filter.toLowerCase().trim()) !== -1 ||
                        plugins[plugin].Category.toLowerCase().trim().indexOf(filter.toLowerCase().trim()) !== -1 ||
                        filter === "") {                                                                                        // filter elements
                        if (start) channels.push(new channel(plugins[plugin].Category, plugins[plugin].ClassName, plugins[plugin].Channels[item].Name, plugins[plugin].Channels[item].Desc, plugins[plugin].Channels[item].Type, plugins[plugin].Channels[item].IO, plugins[plugin].Channels[item].Min, plugins[plugin].Channels[item].Max, plugins[plugin].Channels[item].Units));
                        var channelIcon = parent.categories[parent.categories.map(function (e) { return e.Cat; }).indexOf(plugins[plugin].Category)].Icon;     // 0 index category is 'ALL' so add 1
                        var IOIcon;
                        var chElem = document.createElement("li");
                        chElem.style.setProperty("cursor", "pointer");
                        chElem.className = "tip"
                        chElem.setAttribute("data-original-title", plugins[plugin].Channels[item].Desc);
                        chElem.id = plugins[plugin].Category + "/" + plugins[plugin].ClassName + "/" + plugins[plugin].Channels[item].Name       // store the category, class and channel names in the ID field for future use
                        if (!plugins[plugin].Channels[item].IO) plugins[plugin].Channels[item].IO = ""
                        switch (plugins[plugin].Channels[item].IO.toLowerCase()) {                                                  // select icon to represent channel direction
                            case "input":
                                IOIcon = "sort-up"
                                break;
                            case "output":
                                IOIcon = "sort-down"
                                break;
                            case "inputoutput":
                                IOIcon = "sort"
                                break;
                            default:
                                IOIcon = "question-mark"
                        }
                        chElem.innerHTML = "<i class='icon-" + IOIcon + "' icon-large>&nbsp;</i><i class='icon-" + channelIcon + " icon-large' id='" + plugins[plugin].Category + "/" + plugins[plugin].ClassName + "/" + plugins[plugin].Channels[item].Name + "'></i><br/>" + plugins[plugin].ClassName + "<br/>" + plugins[plugin].Channels[item].Name + "<br/><br/>"
                        ChContainer.appendChild(chElem)
                    }
                }
            }
        }

        //#region        //////////////////////////////////////////// load widgets

        // Load the widget toolbox
        function initTBWidgets(widgetNames, filter) {
            var frag = document.createDocumentFragment();
            var widgetTemplates = widgetNames.split(",");
            for (var widgetNum = 0; widgetNum < widgetTemplates.length; widgetNum++) {
                var widgetNameType = widgetTemplates[widgetNum].split(".")
                if (widgetNameType[0].toLowerCase().trim().indexOf(filter.toLowerCase().trim()) !== -1 || filter === "") {          // filter search
                    TBwidgets.push(new widget(widgetNameType[0], widgetNameType[1]));
                    var widgetObj = document.createElement("object");
                    widgetObj.type = "text/html";
                    widgetObj.data = "widgets/" + widgetTemplates[widgetNum] + parent.debugURL                                      // location of widget (and not from cache if debugging)
                    widgetObj.setAttribute("data-type", widgetNameType[0]);
                    widgetObj.id = "widgetObjTB" + widgetNum;
                    var title = document.createElement("p");
                    title.innerHTML = "<span>" + widgetNameType[0] + "</span><br /><br />";
                    widgetObj.addEventListener("load", widgetTBloaded);
                    frag.appendChild(widgetObj);                                                                                    // Add to toolbox Div
                    frag.appendChild(title);
                }
            }
            document.getElementById("widgetToolboxScroll").appendChild(frag);
        }

        // finish toolbox widget load
        function widgetTBloaded(e) {
            var loadDoc = e.currentTarget.contentDocument;
            var TBWidget = loadDoc.getElementById("widget");
            var widgetNum = parseInt(e.currentTarget.id.replace("widgetObjTB", ""));
            try {
                var widgetWidth = Math.min(TBWIDGETWIDTH, parseInt(TBWidget.getAttribute("width")) || parseInt(TBWidget.style.getPropertyValue("width")));
                var widgetHeight = Math.min(TBWIDGETWIDTH, parseInt(TBWidget.getAttribute("height")) || parseInt(TBWidget.style.getPropertyValue("height")));
                e.currentTarget.width = widgetWidth;
                e.currentTarget.height = widgetHeight;
                loadDoc.defaultView.widgetLoad(e.currentTarget.id);                                                                 // Run the widget API startup (must be done from parent to pass name)
                loadDoc.defaultView.fw.iniWidth = widgetWidth;
                loadDoc.defaultView.fw.iniHeight = widgetHeight;
                if (typeof loadDoc.defaultView.scale === "function") loadDoc.defaultView.scale(1, 1);
                if (typeof loadDoc.defaultView.toolStart === "function") loadDoc.defaultView.toolStart();
                TBWidget.style.setProperty("cursor", "move");
                widgetListeners(loadDoc);
                $("#" + e.currentTarget.id).tooltip({ title: loadDoc.getElementById("TBtooltip").getAttribute("data-default"), delay: { show: 2000 } });
            } catch (err) {
                e.currentTarget.parentNode.removeChild(e.currentTarget);                                                            // remove widget
                alert("WARNING - widget '" + TBwidgets[widgetNum].type + "' is corrupt and won't be usable in the toolbox. " + err.toString());
                TBwidgets[widgetNum].type = null;
            }
        }

        // Initialise the widgets from initial connection load
        function initWidgets(widgetsJSON) {
            if (widgetsJSON !== "") {
                var serverWidgets = JSON.parse(widgetsJSON)
                for (var i = 0; i < serverWidgets.length; i++) {
                    if (serverWidgets[i].lX + serverWidgets[i].w > widgetMax.width) widgetMax.width = serverWidgets[i].lX + serverWidgets[i].w;
                    if (serverWidgets[i].lY + serverWidgets[i].h > widgetMax.height) widgetMax.height = serverWidgets[i].lY + serverWidgets[i].h;
                    var myWidget = new widget(serverWidgets[i].t, serverWidgets[i].e, serverWidgets[i].s, serverWidgets[i].lX, serverWidgets[i].lY);
                    myWidget.scaleX = serverWidgets[i].sX;
                    myWidget.scaleY = serverWidgets[i].sY;
                    myWidget.iniWidth = serverWidgets[i].w;
                    myWidget.iniHeight = serverWidgets[i].h;
                    myWidget.zOrder = serverWidgets[i].z;
                    var widgetAttribs = [];
                    for (var y = 0; y < serverWidgets[i].a.length; y++) widgetAttribs.push({ name: serverWidgets[i].a[y].n, type: serverWidgets[i].a[y].t, value: serverWidgets[i].a[y].v })
                    myWidget.attribs = widgetAttribs;
                    widgets.push(myWidget);                                                                             // rehydrate widget compressed for faster network
                }
                if (typeof uwpHost !== "undefined") {                                                                   // for UWP hosting, set screen size
                    uwpHost.setMaxSize(widgetMax.width, widgetMax.height)
                }
            }
            selectedTab(0, true);                                                                                       // load the first screen & don't show screen fade for faster startup
        }

        // Create widgets
        function loadWidget(myFrag, widgetNum) {
            var widgetObj = document.createElement("object");
            widgetObj.type = "text/html";
            widgetObj.data = "widgets/" + widgets[widgetNum].type + "." + widgets[widgetNum].ext + parent.debugURL      // location of widget
            widgetObj.className = "widget";
            widgetObj.id = "widgetObj" + widgetNum;
            widgetObj.addEventListener("load", widgetLoaded, false);
            myFrag.appendChild(widgetObj);                                                                              // build widgets onto fragment
        }

        // finish widget setup once the widget is loaded
        function widgetLoaded(e) {
            var loadObj = e.currentTarget;
            var loadNum = parseInt(loadObj.id.replace("widgetObj", ""));
            var loadDoc = loadObj.contentDocument;
            var widgetID = loadDoc.getElementById("widget");
            try {
                if (g.design) {                                                                                       // setup initial settings when the widget is first created
                    widgets[loadNum].iniHeight = parseInt(widgetID.getAttribute("height")) || parseInt(widgetID.style.getPropertyValue("height"));
                    widgets[loadNum].iniWidth = parseInt(widgetID.getAttribute("width")) || parseInt(widgetID.style.getPropertyValue("width"));
                    for (var i = 0; true; i++) {                                                                    // read the data attributes from the SPAN tags to populate attrib array
                        var attribID = loadDoc.getElementById("attrib" + i);
                        if (!attribID) break;
                        widgets[loadNum].attribs.push(new widgetAttrib(attribID.getAttribute("data-name"), attribID.getAttribute("data-type"), attribID.getAttribute("data-default")));
                    }
                    if (loadDoc.getElementById("ontop").getAttribute("data-default") === "true") widgets[loadNum].zOrder = 100;
                    dragData.widgetObj = loadObj;                                                                   // drag from toolbox needs to wait until widget created
                    widgetID.style.setProperty("cursor", "move");
                    widgetListeners(loadDoc);
                }

                loadDoc.defaultView.widgetLoad(loadObj.id);                                                         // Run the widget API startup (must be done from parent to pass name)
                if (g.design && typeof loadDoc.defaultView.startDesign === "function") loadDoc.defaultView.startDesign();

                widgetID.setAttribute("data-type", widgets[loadNum].type);                                          // widget type = classname for messages
                loadObj.setAttribute("style", "position:absolute;overflow:hidden;left:" + widgets[loadNum].locX + "px;top:" + widgets[loadNum].locY + "px;z-index:" + widgets[loadNum].zOrder);
                loadObj.width = widgets[loadNum].scaleX * parseInt(widgets[loadNum].iniWidth);
                loadObj.height = widgets[loadNum].scaleY * parseInt(widgets[loadNum].iniHeight);

                widgetLoadedCnt += 1;
                var startRet = "OK";
                if (typeof loadDoc.defaultView.dashStart === "function") var startRet = loadDoc.defaultView.dashStart();

                if (startRet.toUpperCase() !== "OK") throw "Widget failed startup - " + startRet;
                var gScale = loadDoc.getElementById("scale");
                //if (gScale && +widgets[loadNum].scaleX !== 1 && +widgets[loadNum].scaleY !== 1) gScale.setAttribute("transform", "scale(" + widgets[loadNum].scaleX + "," + widgets[loadNum].scaleY + ")");
                if (typeof loadDoc.defaultView.scale === "function") loadDoc.defaultView.scale(+widgets[loadNum].scaleX, +widgets[loadNum].scaleY);

                if (widgetToLoadCnt === widgetLoadedCnt) {                                                          // Finished loading all the widgets on the screen
                    setTimeout(afterRender, 0);
                }
            } catch (err) {
                loadObj.parentNode.removeChild(loadObj);                                                            // remove widget
                if (parent.debugURL !== "") throw err.stack || err;                                                 // let debugger catch the error if debugging
                alert("WARNING - Problems loading widget #" + loadNum + " (" + widgets[loadNum].type + "). Widget won't be useable. Details: " + err);         // else show the user a nice error box
                widgets[loadNum].type = null;
            }
        }

        // Display screen as fast as possible, put non essential tasks to finish widget loading here
        function afterRender() {
            document.getElementById("fade").style.setProperty("display", "none");                                   // finally show the widgets!
            document.getElementById("widgetContainer").style.setProperty("left", "0px");
            parent.status("Ready");
            parent.enableTooltip();
            parent.send("SETTINGS", "GET:CATEGORIES()", "");
            var myWidgets = document.getElementsByClassName("widget");
            for (var i = 0; i < myWidgets.length; i++) widgetListeners(myWidgets[i].contentDocument.defaultView);
            if (!g.design && parent.mode === "Design") setDesign();                                                   // Go into design mode if just reloaded after pressing design button
        }

        function widgetListeners(myWidget) {
            myWidget.addEventListener("contextmenu", function (event) { event.preventDefault(); return false; });   // stop browser right click menu
            myWidget.addEventListener('mousemove', mouseMove, false);
            myWidget.addEventListener('mouseup', mouseUp, false);
            myWidget.addEventListener('mousedown', mouseDown, false);
            myWidget.addEventListener("dblclick", widgetDblClick, false);
        }

        ///////////////////////////////////////////////// Widget mouse events

        // Handle mouse click over widget depending on mode
        function mouseDown(event) {
            if (g.design) {
                if (event.which === 3) {                                                                            // right click
                    showWidgetMenu(event.target.ownerDocument.defaultView.fw.widgetName);                           // in design mode, show the widget menu
                    if (typeof event.currentTarget.designRHClicked === "function") event.currentTarget.designRHClicked(event);        // run the click event in the widget
                } else {
                    dragData.widgetName = event.target.ownerDocument.defaultView.fw.widgetName;
                    if (dragData.widgetName.indexOf("TB") === -1) {                                                 // Dragging existing widget
                        dragData.widgetNum = parseInt(dragData.widgetName.replace("widgetObj", ""));
                        dragData.widgetObj = document.getElementById(dragData.widgetName);
                        dragData.startX = parseInt(dragData.widgetObj.style.left) - event.screenX;
                        dragData.startY = parseInt(dragData.widgetObj.style.top) - event.screenY;
                    } else dragData.widgetName = "new";                                                             // Dragging new widget from toolbox
                }
            } else {
                if (typeof event.currentTarget.clicked === "function") event.currentTarget.clicked(event);          // run the click event in the widget
            }
            event.preventDefault();                                                                                 // stop HTML5 drag drop
        }

        // Handle mouse moving over widget depending on mode (drag new widget from toolbox, drag existing widget)
        function mouseMove(event) {
            if (dragData.widgetName) {                                                                              // Adjust the widget position if dragging
                if (dragData.widgetName === "new") {                                                                // drag new widget from toolbox, create it first
                    var TBWidgetNum = parseInt(event.target.ownerDocument.defaultView.fw.widgetName.replace("widgetObjTB", ""));
                    dragData.startX = -event.screenX;
                    dragData.startY = document.getElementById("widgetObjTB" + TBWidgetNum).offsetTop - document.getElementById("widgetToolbox").scrollTop - event.screenY;
                    dragData.newWidget = true;
                    dragData.widgetNum = widgets.length;
                    dragData.widgetName = "widgetObj" + dragData.widgetNum;

                    widgets.push(new widget(TBwidgets[TBWidgetNum].type, TBwidgets[TBWidgetNum].ext, selScreenNum, event.screenX, event.screenY));
                    var frag = document.createDocumentFragment();
                    loadWidget(frag, dragData.widgetNum);                                                           // create new widget if dragging from widget template & don't run widget startup routine as attribs have not been set
                    document.getElementById("mainBody").appendChild(frag);                                          // Add object to body so it can be dragged over everything
                } else {
                    if (dragData.widgetObj) {                                                                       // only drag if not rescaling & if I'm a new widget from the toolbox I have been created
                        dragData.widgetObj.style.setProperty("left", Math.round((dragData.startX + event.screenX) / DESIGNGRID) * DESIGNGRID + "px");
                        dragData.widgetObj.style.setProperty("top", Math.round((dragData.startY + event.screenY) / DESIGNGRID) * DESIGNGRID + "px");
                        g.dirty = true;
                    }
                }
            } else if (typeof event.currentTarget.mouseMove === "function") event.currentTarget.mouseMove(event);   // Send mousemove to widget if it wants it
        }

        // Handle widget mouse up depending on mode (edit mode set here not on mousedown as we could be dragging with mousedown)
        function mouseUp(event) {
            if (dragData.widgetName) {
                if (!editData.scaling && widgets[dragData.widgetNum].locX === parseInt(dragData.widgetObj.style.left) && widgets[dragData.widgetNum].locY === parseInt(dragData.widgetObj.style.top)) {
                    if (setEdit(dragData.widgetName) === -1) resetEdit(dragData.widgetName);                                                        // Toggle edit mode if widget hasn't been dragged
                }
                if (dragData.newWidget) {
                    if (dragData.widgetObj.offsetLeft < TBWIDTH) dragData.widgetObj.style.setProperty("left", TBWIDTH + "px");                      // Move widget over to canvas if dropped on the toolbox
                    dragData.widgetObj.style.setProperty("left", parseInt(dragData.widgetObj.style.getPropertyValue("left")) - TBWIDTH + "px");     // adjust for widgetcontainer offset
                    dragData.widgetObj.contentDocument.getElementById("widget").style.setProperty("cursor", "default");
                    document.getElementById("widgetsDiv").appendChild(dragData.widgetObj);                                                          // Move from body to widget container
                    setEdit(dragData.widgetName);
                    if (typeof dragData.widgetObj.contentDocument.defaultView.newWidget === "function") dragData.widgetObj.contentDocument.defaultView.newWidget();         // widget created routine in widget
                    g.dirty = true;
                }
                widgets[dragData.widgetNum].locX = parseInt(dragData.widgetObj.style.left);
                widgets[dragData.widgetNum].locY = parseInt(dragData.widgetObj.style.top);
                dragData = {};
            }
        }

        ////////////////////////////////////////// widget edit state

        function setEdit(widgetName) {
            if (editData.widgetName === widgetName) return -1;                                                      // Don't run setEdit on the same widget if it is already being edited
            if (editData.widgetName) resetEdit(editData.widgetName);                                                // turn off edit mode for any widget currently being edited

            editData.widgetNum = parseInt(widgetName.slice(9));                                                     // Setup various DOM pointers
            editData.widgetName = widgetName;
            editData.widgetObj = document.getElementById(widgetName);
            editData.widgetDoc = editData.widgetObj.contentDocument;
            editData.widgetEl = editData.widgetDoc.getElementById("widget");
            editData.widgetView = editData.widgetDoc.defaultView;

            parent.status("Editing widget #" + editData.widgetNum + " (" + widgets[editData.widgetNum].type + ")");
            editData.widgetObj.style.setProperty("outline", "gray dotted 1px")

            var mySVG = editData.widgetDoc.createElementNS("http://www.w3.org/2000/svg", "svg");
            mySVG.id = "dragHdls";
            mySVG.appendChild(dragAtts("n-resize", "dragY", 2, 1));
            mySVG.appendChild(dragAtts("e-resize", "dragX", 1, 2));
            mySVG.appendChild(dragAtts("se-resize", "dragXY", 1, 1));

            editData.widgetDoc.getElementById("body").appendChild(mySVG);
            editData.widgetDoc.getElementById("dragHdls").setAttribute("style", "position: absolute; left:0px; z-index:998");               // ensure SVG elements stay on top
            editData.widgetView.fw.state = "edit";

            if (typeof editData.widgetView.startEdit === "function") editData.widgetView.startEdit();
        }

        function dragAtts(cursor, id, widthHalf, heightHalf) {
            var svgDrag = editData.widgetDoc.createElementNS("http://www.w3.org/2000/svg", "rect");

            svgDrag.setAttribute("id", id);
            svgDrag.setAttribute("height", GRABSIZE);
            svgDrag.setAttribute("width", GRABSIZE);
            svgDrag.setAttribute("x", (editData.widgetView.innerWidth - GRABSIZE) / widthHalf);
            svgDrag.setAttribute("y", (editData.widgetView.innerHeight - GRABSIZE) / heightHalf);
            svgDrag.setAttribute("style", "fill:gray; stroke-width:0; cursor: " + cursor);

            svgDrag.addEventListener("mousedown", widgetResizeStart, false);                                                                // start resize when pressing mouse on the resize handle
            return svgDrag;
        }

        function resetEdit(widgetName) {
            document.getElementById("widgetOptionMenu").style.setProperty("display", "none");                                               // cancel widget option menu if open
            if (typeof editData.widgetView.endEdit === "function") if (editData.widgetView.endEdit() === -1) return -1                      // call widget end edit routine, if it returns -1, then don't reset edit state

            editData.widgetView.fw.state = "design";
            editData.widgetObj.style.setProperty("outline", "none");
            editData.widgetDoc.getElementById("dragHdls").parentNode.removeChild(editData.widgetDoc.getElementById("dragHdls"));
            editData = {};

            parent.status("Designer mode");
        }

        /////////////////////////////////////////////// widget resize

        function widgetResizeStart(event) {
            editData.dragID = event.currentTarget.getAttribute("id");
            editData.startX = event.screenX - (widgets[editData.widgetNum].scaleX - 1) * widgets[editData.widgetNum].iniWidth;              // mouse absolute position in the widgetcontainer
            editData.startY = event.screenY - (widgets[editData.widgetNum].scaleY - 1) * widgets[editData.widgetNum].iniHeight;
            editData.initialWidth = editData.widgetView.innerWidth / widgets[editData.widgetNum].scaleX;
            editData.initialHeight = editData.widgetView.innerHeight / widgets[editData.widgetNum].scaleY;

            if (editData.dragID === "dragX") editData.widgetEl.style.setProperty("cursor", "e-resize");
            if (editData.dragID === "dragY") editData.widgetEl.style.setProperty("cursor", "n-resize");
            if (editData.dragID === "dragXY") editData.widgetEl.style.setProperty("cursor", "se-resize");

            var allWidgets = document.querySelectorAll(".widget");
            for (var i = 0; i < allWidgets.length; i++) addScaleListeners(allWidgets[i].contentDocument);                                   // As <objects> swallow events, need to put listeners on each widget on the canvas to allow mouse to move over another widget when resizing
            addScaleListeners(editData.widgetDoc);
            addScaleListeners(document.getElementById("cvsDesign"));
            editData.scaling = true;
            event.stopPropagation();                                                                                                        // Don't bubble up to widget mousedown event
        }

        function addScaleListeners(obj) {
            obj.addEventListener("mousemove", mouseMoveDrag, false);
            obj.addEventListener("mouseup", widgetResizeEnd, false);
        }

        // only allow either X dragging, Y dragging, or proportional XY dragging
        function mouseMoveDrag(event) {
            if (editData.scaling) {
                var sizeChange;
                if (editData.dragID !== "dragY") {
                    var newWidth = Math.round((editData.initialWidth + event.screenX - editData.startX) / DESIGNGRID) * DESIGNGRID;         // only allow grid gap increments
                    if (newWidth <= 0) return false;                                                                                        // Don't scale negative
                    editData.widgetObj.width = newWidth;
                    sizeChange = "Width: " + parseInt(newWidth * 100 / editData.initialWidth) + "%";
                    widgets[editData.widgetNum].scaleX = newWidth / editData.initialWidth;

                    editData.widgetEl.setAttribute("width", newWidth + GRABSIZE / 2);
                    editData.widgetDoc.getElementById("dragXY").setAttribute("x", newWidth - GRABSIZE);
                    editData.widgetDoc.getElementById("dragX").setAttribute("x", newWidth - GRABSIZE);
                    editData.widgetDoc.getElementById("dragY").setAttribute("x", (newWidth - GRABSIZE) / 2);
                }
                if (editData.dragID !== "dragX") {
                    var newHeight = Math.round((editData.initialHeight + event.screenY - editData.startY) / DESIGNGRID) * DESIGNGRID;
                    sizeChange = "Height: " + parseInt(newHeight * 100 / editData.initialHeight) + "%";

                    if (editData.dragID === "dragXY") {
                        newHeight = widgets[editData.widgetNum].scaleX * editData.initialHeight;                                            // For XY drag, only scale with X to preserve widget proportions
                        sizeChange = "Size: " + parseInt(newWidth * 100 / editData.initialWidth) + "%";
                    }
                    if (newHeight <= 0) return false;                                                                                       // Don't scale negative
                    editData.widgetObj.height = newHeight;
                    widgets[editData.widgetNum].scaleY = newHeight / editData.initialHeight;

                    editData.widgetEl.setAttribute("height", newHeight + GRABSIZE / 2);
                    editData.widgetDoc.getElementById("dragXY").setAttribute("y", newHeight - GRABSIZE);
                    editData.widgetDoc.getElementById("dragX").setAttribute("y", (newHeight - GRABSIZE) / 2);
                    editData.widgetDoc.getElementById("dragY").setAttribute("y", newHeight - GRABSIZE);
                }
                editData.widgetView.scale(widgets[editData.widgetNum].scaleX, widgets[editData.widgetNum].scaleY);
                parent.status(sizeChange);
            }
        }

        function widgetResizeEnd(event) {
            editData.scaling = false;
            var allWidgets = document.querySelectorAll(".widget");
            for (var i = 0; i < allWidgets.length; i++) removeScaleListeners(allWidgets[i].contentDocument);

            removeScaleListeners(editData.widgetDoc);
            removeScaleListeners(document.getElementById("cvsDesign"));
            removeScaleListeners(document.getElementById("widgetContainer"));
            removeScaleListeners(document.getElementById("cvsDesign"));

            editData.widgetEl.style.setProperty("cursor", "default");
            g.dirty = true;
        }

        function removeScaleListeners(obj) {
            obj.removeEventListener("mousemove", mouseMoveDrag, false);
            obj.removeEventListener("mouseup", widgetResizeEnd, false);
        }

        //#endregion

        ///////////////////////////////////////////// widget events

        // Click the canvas blank areas (not widgets)
        function canvasClick() {
            if (g.design && editData.widgetNum) resetEdit(editData.widgetName);                                                             // turn off editing for any widget being edited
            return false;
        }

        // Double click the widget
        function widgetDblClick(event) {
            if (typeof event.currentTarget.dblClicked === "function") event.currentTarget.dblClicked(event);
            return false;
        }

        // Process global keypresses, handle for designer and send to widgets if they want it
        function keyPress(e) {
            if (g.design && editData.widgetName && !g.menuOpen) {
                switch (e.keyCode) {
                    case 13:                    // Enter
                        break;
                    case 46:                    // Del
                        parent.modalDialog('text', 'Delete Widget', 'Confirm that you want to delete ' + widgets[editData.widgetNum].type + '?', 'Delete', 'deleteWidget', editData.widgetNum)
                        break;
                    case 27:                    // ESC
                        closeWidgetMenu("cancel");
                        resetEdit(editData.widgetName);
                        break;
                    case 37:                    // Left arrow
                        editData.widgetObj.style.setProperty("left", (widgets[editData.widgetNum].locX - DESIGNGRID) + "px");               // move editing widget left by a grid space
                        widgets[editData.widgetNum].locX -= DESIGNGRID;
                        g.dirty = true;
                        break;
                    case 38:                    // Up arrow
                        editData.widgetObj.style.setProperty("top", (widgets[editData.widgetNum].locY - DESIGNGRID) + "px");                // move editing widget up by a grid space
                        widgets[editData.widgetNum].locY -= DESIGNGRID;
                        g.dirty = true;
                        break;
                    case 39:                    // Right arrow
                        editData.widgetObj.style.setProperty("left", (widgets[editData.widgetNum].locX + DESIGNGRID) + "px");               // move editing widget right by a grid space
                        widgets[editData.widgetNum].locX += DESIGNGRID;
                        g.dirty = true;
                        break;
                    case 40:                    // Down arrow
                        editData.widgetObj.style.setProperty("top", (widgets[editData.widgetNum].locY + DESIGNGRID) + "px");                // move editing widget down by a grid space
                        widgets[editData.widgetNum].locY += DESIGNGRID;
                        g.dirty = true;
                        break;
                    default:
                }
            }
            var allWidgets = document.querySelectorAll(".widget");                                                                          // send keypress to widgets if they want them
            for (var i = 0; i < allWidgets.length; i++) if (typeof allWidgets[i].contentDocument.defaultView.keyPress === "function") allWidgets[i].contentDocument.defaultView.keyPress(e.keyCode);
            return false;
        }

        function recvHost(msg) {
            switch (msg.ClassName.toUpperCase()) {
                case "INITLOAD":
                    initScreens(msg.Data.Screens);
                    initWidgets(msg.Data.Widgets);                                                                                          // show the tabs then load widgets
                    break;
                case "SCREENS":
                    switch (msg.Scope.toUpperCase()) {
                        case "LOAD":
                            initScreens(msg.Data);
                            break;
                        default:
                    }
                    break;
                case "HISTORY":
                    (function (myMsg) {                                                                                                     // closure used as msg changes while waiting for data to load
                        for (var history = 0; history < histReqs.length; history++) {
                            if (histReqs[history].channel = myMsg.Scope) {
                                widgetAction("widgetObj" + histReqs[history].widgetNum, "history", myMsg.Scope.split("/")[2], histReqs[history].range, myMsg.Data);
                                histReqs.splice(history, 1)                                                                                 // remove from request cache
                                break;
                            }
                        }
                    })(msg);
                    break;
                case "WIDGETS":
                    switch (msg.Scope.toUpperCase()) {
                        case "LOAD":
                            initWidgets(msg.Data);
                            break;
                        case "TOOLBOX":
                            initTBWidgets(msg.Data, "");
                            break;
                        case "CHANNELS":
                            plugins = JSON.parse(msg.Data);
                            loadChannels("", true);
                            break;
                        case "IMAGE":                                                                                                   // &&&&&&&&&&&&&&&&&&&&&&&& TODO: Consider making this more generic rather than hard coded for the image widget
                            widgetAction("widgetObj" + msg.Data, "load")
                            break;
                        case "INISUB":                                                                                                      // initial state information from host plugins widgets subscribed to
                            if (msg.Data !== "{}") widgetIni(msg.Data);
                            break;
                        default:
                    }
                    break;
                default:                                                                                                                    // General network message, send to subscribed widgets
                    for (var widgetNum = 0; widgetNum < widgets.length; widgetNum++) {
                        if (!g.design && widgets[widgetNum].screen === selScreenNum) {
                            for (var attrib = 0; attrib < widgets[widgetNum].attribs.length; attrib++) {
                                if (widgets[widgetNum].attribs[attrib].type === "channel") {
                                    if (widgets[widgetNum].attribs[attrib].value.toUpperCase() === msg.Category.toUpperCase() + "/" + msg.ClassName.toUpperCase() + "/" + msg.Instance.toUpperCase()) {
                                        widgetAction("widgetObj" + widgetNum, "feed", msg.Instance, msg.Scope, msg.Data);
                                    }
                                }
                            }
                        }
                    }
            }
        }

        // Set the initial state of the widgets based on the server return of state data when screen is initialised
        function widgetIni(widgetParams) {
            var cacheData = JSON.parse(widgetParams);
            for (var cacheCh in cacheData) {                                                                                                // data in the format key "category/class/instance" data "scope:value, .." where category/class/instance is the channel name
                for (var widgetNum = 0; widgetNum < widgets.length; widgetNum++) {
                    if ((widgets[widgetNum].screen === selScreenNum)) {                                                                     // only action for active widgets on the screen
                        for (var attrib = 0; attrib < widgets[widgetNum].attribs.length; attrib++) {                                        // go looking through widget attributes for a channel
                            if (widgets[widgetNum].attribs[attrib].type === "channel" && widgets[widgetNum].attribs[attrib].value === cacheCh) {
                                var splitParams = cacheData[cacheCh].indexOf(":")
                                widgetAction("widgetObj" + widgetNum, "ini", cacheCh.split("/")[2], cacheData[cacheCh].substr(0, splitParams), cacheData[cacheCh].substr(splitParams + 1))
                            }
                        }
                    }
                }
            }
        }

        // Main interface for requests coming from widgets for framework services
        function widgetRequest(widgetName, func, param0, param1, param2, param3) {
            var widgetNum = parseInt(widgetName.slice(9));
            var widgetObj = document.getElementById(widgetName);
            switch (func.toLowerCase()) {
                case "settooltip":
                    if (param0 === "") {
                        $("#" + widgetName).tooltip("destroy");
                    } else {
                        $("#" + widgetName).tooltip({ title: param0, delay: { show: 800 }, placement: "auto top", html: true });
                    }
                    break;
                case "display":                                                                                                             // display or hide widget
                    if (param0 === true) {
                        widgetObj.style.setProperty("display", "inline");
                    } else {
                        widgetObj.style.setProperty("display", "none");
                    }
                    return
                    break;
                case "getattrib":                                       
                    return widgets[widgetNum].attribs[param0].value;
                    break;
                case "setattrib":
                    widgets[widgetNum].attribs[param0].value = param1;
                    break;
                case "newattrib":
                    widgets[widgetNum].attribs.push(new widgetAttrib(param0, param1, param2));                                              // Add a new attrib to the widget (eg. for a dynamic channel or state store)
                    break;
                case "subscribe":
                    parent.send("WIDGETS", "INISUB", param0)                                                                                // resigter the channel on the host
                    widgets[widgetNum].attribs.push(new widgetAttrib("", "channel", param0));                                               // add channel attrib (blank name = hidden) so that channel messages from host will be sent to widget
                    break;
                case "getchannels":                                                                                                         // Get all the channels for a server plugin (param0 = category, param1 = class/plugin name
                    return (typeof plugins[param0.toUpperCase() + "/" + param1.toUpperCase()] !== undefined) ? plugins[param0.toUpperCase() + "/" + param1.toUpperCase()].Channels : ""
                    break;
                case "selectchannels":
                    toggleToolbox("channelToolbox", "open");
                    break;
                case "save":
                    saveScreen();
                    break;
                case "zorder":
                    widgetObj.style.setProperty("z-index", param0);
                    break;
                case "updatestatus":
                    parent.status(param0);
                    break;
                case "servername":
                    return parent.serverName;
                    break;
                case "history":
                    (function (widgetNum, param0, param1, param2, param3) {
                        histReqs.push({ "widgetNum": widgetNum, "channel": param0, "range": param1 + "," + param2 });                       // Save history request so results can be sent back to widget
                        parent.send("HISTORY", param0, param1 + "," + param2)                                                               // Get history records for channel (param0) since time (param1) in javascript time
                    })(widgetNum, param0, param1, param2, param3);
                    break;
                case "send":
                    if (param0.split("/").length !== 3) return false;                                                                       // channel must be in the form CATEGORY/classname/instance
                    parent.channelSend(param0.toString(), param1.toString(), param2.toString());
                    for (var widget = 0; widget < widgets.length; widget++) {                                                               // if other widgets on the screen subscribe to the same channel send message to them as message won't be echoed back
                        if ((widgetNum !== widget) && (widgets[widget].screen === selScreenNum)) {
                            for (var attrib = 0; attrib < widgets[widget].attribs.length; attrib++) {
                                if (widgets[widget].attribs[attrib].type === "channel" && widgets[widget].attribs[attrib].value === param0) widgetAction("widgetObj" + widget, "feed", param0, param1, param2)
                            }
                        }
                    }
                    break;
                case "adjustsize":                                                                                                          // Adjust parent container for widgets that manage their own shape
                    switch (param0.toLowerCase()) {
                        case "width":
                            widgetObj.style.setProperty("width", param1 + "px")
                            break;
                        case "height":
                            widgetObj.style.setProperty("height", param1 + "px")
                            break;
                        case "topoffset":
                            widgetObj.style.setProperty("top", (parseInt(widgetObj.style.getPropertyValue("top")) + parseInt(param1)) + "px")
                            widgets[widgetNum].locY = parseInt(widgetObj.style.getAttribute("top"))
                            break;
                        case "leftoffset":
                            widgetObj.style.setProperty("left", (parseInt(widgetObj.style.getPropertyValue("left")) + parseInt(param1)) + "px")
                            widgets[widgetNum].locX = parseInt(widgetObj.style.getAttribute("left"))
                            break;
                        case "scalex":
                            widgets[widgetNum].scaleX = param1;
                            break;
                        case "scaley":
                            widgets[widgetNum].scaleY = param1;
                            break;
                        default:
                    }
                    break;
                default:
                    return false;                                                                                                           // invalid function
            }
            return true;
        }

        // Main interface for requests from host to widget. Recursively wait if widget has not finished loading
        function widgetAction(widgetName, func, param0, param1, param2, initAction) {
            var widgetNum = parseInt(widgetName.slice(9));
            if (widgets[widgetNum].loadCnt < WIDGETLOADRETRIES && widgets[widgetNum].type) {                                                // If not too many retries and widget loaded OK
                var widgetObj = document.getElementById(widgetName);                                                                         // Is widget loaded?
                if (widgetObj) {                                                                                                             // Not even on the page, ignore message as a new page is loaded
                    if (widgetObj.contentDocument && typeof widgetObj.contentDocument.defaultView.fw === "object") {                          // function may not exist yet if widget is still loading
                        widgets[widgetNum].loadCnt = 0
                        if (!g.design) {                                                                                                    // actions requested from the host: msg.Instance, msg.Scope, msg.Data
                            switch (func) {
                                case "feed":                                                                                                // channel event updates
                                    widgetObj.contentDocument.defaultView.feed(param0, param1, param2);
                                    break;
                                case "ini":                                                                                                 // initial channel state
                                    if (typeof widgetObj.contentDocument.defaultView.ini === "function") return widgetObj.contentDocument.defaultView.ini(param0, param1, param2);
                                    break;
                                case "msg":                                                                                                 // any general message
                                    if (typeof widgetObj.contentDocument.defaultView.msg === "function") return widgetObj.contentDocument.defaultView.msg(param0, param1, param2);
                                    break;
                                case "history":                                                                                             // history of message logs in JSON
                                    if (typeof widgetObj.contentDocument.defaultView.history === "function") return widgetObj.contentDocument.defaultView.history(param0, param1, param2);
                                    break;
                                default:
                                    return false;
                            }
                        } else if (typeof widgetObj.contentDocument.defaultView.designAction === "function") return widgetObj.contentDocument.defaultView.designAction(func, param0, param1, param2);
                    } else {
                        widgets[widgetNum].loadCnt = widgets[widgetNum].loadCnt + 1;
                        setTimeout(widgetAction, ACTION_RETRY_MSEC, widgetName, func, param0, param1, param2, "retry");                     // Not quite finished loading
                    }
                }
            } else {
                parent.status("WARNING - Widget " + widgetName + " (" + widgets[widgetNum].type + ") can't receive request'" + func + " ' params:" + param0 + ", " + param1 + ", " + param2 + "). Try reloading the page.");
                return false;
            }
            return true;
        }

        ///////////////////////////////// Utilities

        // Handle callbacks from the modal option selected
        function modalCallback(modalFunction, param1, param2, param3, param4) {
            if (window[modalFunction] !== undefined) window[modalFunction](param1, param2, param3, param4)
        }

        // Callback for setting up new device
        function newDevice() {
            parent.adjustNavBar("Design");
            newScreen();
        }

        // JQuery/BS JS used for modal and tooltips, load late
    </script>
    <script defer src="js/jquery-3.1.0.slim.min.js"></script>
    <script defer src="js/bootstrap.min.js"></script>
</body>
</html>
