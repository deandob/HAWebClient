<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>Home Automation Client</title>
    <meta name="description" content="Home Automation Framework">
    <meta id="version" content="1.0 beta">
    <meta name="author" content="Dean Dobson">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/manifest.json">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/icons.css">
    <link rel="stylesheet" href="css/style.css">
</head>
<body id="navFrame" class="navframe" draggable="false" oncontextmenu="return false;">
    <div class="navbar navbar-default navbar-fixed-top" style="border-top:3px solid #bce8f1" role="navigation">
        <div class="container-fluid">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navCollapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <img class="navbar-brand" src="images\houseicon.png" alt="">
                <span class="navbar-brand" id="headerTitle"></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </div>
            <div class="collapse navbar-collapse" id="navCollapse">
                <ul class="nav navbar-nav">
                    <li class="divider-vertical"></li>
                    <li id="dashButton" class="active" style="display:none"><a onclick="adjustNavBar('Dashboard')" class="tip" data-original-title="View and control home automation" data-placement="bottom"><i class="icon-home icon-large"></i> Dashboard</a></li>
                    <li class="divider-vertical"></li>
                    <li id="settingsButton" class="pointer" style="display:none"><a onclick="adjustNavBar('Settings')" class="tip" data-original-title="Setup events, triggers and system settings" data-placement="bottom"><i class="icon-cog icon-large"></i> Settings</a></li>
                    <li class="divider-vertical"></li>
                    <li id="designButton" class="pointer" style="display:none"><a onclick="adjustNavBar('Design')" class="tip" data-original-title="Manage home automation widgets" data-placement="bottom"><i class="icon-pencil icon-large"></i> Design</a></li>
                    <li class="divider-vertical"></li>
                    <li id="queryButton" class="pointer" style="display:none"><a onclick="adjustNavBar('Flows')" class="tip" data-original-title="Query current and historical values" data-placement="bottom"><i class="icon-search icon-large"></i> Queries</a></li>
                    <li id="toolboxDropdown" class="dropdown pointer" style="display:none">
                        <a class="dropdown-toggle tip" data-toggle="dropdown" data-original-title="Select toolbox from dropdown" data-placement="right"><i class="icon-edit icon-large"></i> Toolbox <b class="caret"></b></a>
                        <ul class="dropdown-menu" role="menu">
                            <li><a onclick="iFrame.contentWindow.toggleToolbox('widgetToolbox', 'open')"><i class="icon-cog-2 icon-large"></i> Widgets</a></li>
                            <li><a onclick="iFrame.contentWindow.toggleToolbox('iconToolbox', 'open')"><i class="icon-library icon-large"></i> Icons</a></li>
                            <li><a onclick="iFrame.contentWindow.toggleToolbox('channelToolbox', 'open')"><i class="icon-tv icon-large"></i> Channels</a></li>
                        </ul>
                    </li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li class="divider-vertical"></li>
                    <li><a id="logonButton" style="visibility: hidden" onclick="login()" class="tip icon pointer" data-original-title="Enter Username" data-placement="bottom"><i class="icon-user icon-large"></i> Login</a></li>
                    <li id="helpButton" class="pointer"><a onclick="adjustNavBar('Help')" class="tip" data-original-title="Press for more information" data-placement="bottom"><i class="icon-question-sign icon-large"></i> Help</a></li>
                </ul>
                <p id="displayUser" class="nav navbar-text navbar-right"></p>
            </div>
        </div>
    </div>
    <iframe id="iFrame" src="dashboard.html" style="border:none;" width="100%"></iframe>
    <footer class="navbar navbar-fixed-bottom">
        <div style="position: absolute; padding:8px 5px 15px 15px; height: 38px; border:1px solid #bce8f1; background-color:#d9edf7; color: #3a87ad; border-radius:4px; bottom: 10px; right: 10px; left: 10px">
            <span id="serverStatus" class="pull-left">Starting Home Automation Client...</span>
            <span id="connType" class="icon-cloud-download-2 icon-large pull-right"></span>
            <span class="pull-right">&nbsp;&nbsp;</span>
            <span id="versionTxt" class="pull-right"></span>
        </div>
    </footer>

    <div id="myModal" class="modal fade" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
                    <h4 id="modalTitle" class="modal-title" style="text-align:center"></h4>
                </div>
                <div class="modal-body">
                    <p id="modalText"></p><br />
                    <form id="formInput" style="display: none">
                        <input id="modalInput" type="email" class="form-control" placeholder="" />
                    </form>
                    <form id="formLogin" class="form-horizontal" role="form" style="display: none">
                        <div class="form-group">
                            <label class="col-lg-2 control-label">Username</label>
                            <div class="col-lg-10">
                                <input type="email" class="form-control" id="inpUsername" placeholder="Enter Username">
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="inputPassword1" class="col-lg-2 control-label">Password</label>
                            <div class="col-lg-10">
                                <input type="password" class="form-control" id="inpPassword" placeholder="Enter Password">
                            </div>
                        </div>
                        <div class="form-group">
                            <div class="col-lg-offset-2 col-lg-10">
                                <div class="checkbox">
                                    <label>
                                        <input type="checkbox"> Remember me
                                    </label>
                                </div>
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button id="cancelButton" onclick="modalCancel()" type="button" class="btn btn-default" data-dismiss="modal">Cancel</button>
                    <button id="modalButton" onclick="modalOK()" type="button" class="btn btn-primary">OK</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        "use strict";

        console.time("profile")

        // Global flags
        var g = {
            net: {
                wsMQTT: null,                               // Reference to client WebSocket
                KEEPALIVE: 60,
                WSPORT: 80,
                retain: true,                               // For publish, server to retain (persist) value
                QoS: 0,                                     // QoS for published messages (0 = no guarantee delivery, 1 = guaranteed delivery, 2 = exactly one delivery). QoS 0 only supported
                netState: "disconnected",
                responseTimeout: 10,                             // Timeout waiting for server to respond
                msgTimer: null,                              // message response setTimeout reference
                keepAliveInterval: null,                     // keepalive period timer reference
                connPayload: null,                          // GLobal for connection payload once websocket connection is open
                sessPresent: null,
                packetID: 0                             // counter for unique packetID
            }
        };

        var ws, clientName;
        var debugURL = "";
        var wsPort = 1066;
        var protocol = location.protocol === "https:" ? "wss:" : "ws:";
        var serverName = document.domain;
        var deviceWidth = screen.availWidth;
        var deviceHeight = screen.availHeight;

        var params = document.URL.split("?");
        if (params.length > 1) params = params[1].split("=");
        switch (params[0].toLowerCase()) {         // command line options after URL '?'
            case "remote":
                document.getElementById("connType").setAttribute("class", "tip icon-cloud-download-2 icon-large pull-right");
                document.getElementById("connType").setAttribute("data-original-title", "remote access");
                wsPort = 80;
                connection = "remote";                                                                                                              // flow onto clientname. parameter is remote=<devicename>
                clientName = params[1].toUpperCase();
                break;
            case "clientname":
                clientName = params[1].toUpperCase();
                localStorage.setItem("clientName", clientName);
                deviceHeight = +localStorage.getItem("impHeight");                                                                                  // If impersonating another client with different width like a phone
                if (!deviceHeight) deviceHeight = screen.availHeight;
                deviceWidth = +localStorage.getItem("impWidth");
                if (!deviceWidth) deviceWidth = screen.availWidth;
                break;
            case "clear":
                if (localStorage.getItem("reloading") !== "true") {
                    localStorage.setItem("clientName", "");
                    clearCache();
                    localStorage.setItem("reloading", "true")
                } else {
                    localStorage.setItem("reloading", "false")
                }
                break;
            case "debug":
                debugURL = "?" + Math.random()          // pass any parameter in the URL line to turn on debugging (force cache reloading) and specify remote websockets server
                if (params.length == 2) serverName = params[1].toUpperCase();
            case "local":
            default:
                document.getElementById("connType").setAttribute("class", "tip icon-home-4 icon-large pull-right")
                document.getElementById("connType").setAttribute("data-original-title", "local access")
        }

        if (typeof clientName === "undefined") {
            clientName = localStorage.getItem("clientName");
            if (!clientName) clientName = "";
        }

        if (debugURL !== "") startMQTTSess()
        else startNet();

        var netState = "starting";
        var msg;

        var func = {
            action: 0,                                          // Action or method call
            response: 1,                                        // Data response to a method call
            event: 2,                                           // Asynchronous event message
            log: 3,                                             // Log Message
            error: 4,                                           // Error Message
            sql: 5                                              // Execute SQL message
        }

        var templMsg = {
            client: clientName,
            func: func.action,
            level: 3,
            network: 1,
            category: "SYSTEM",
            className: "NETWORK",
            instance: null,
            scope: "CONNECT",
            data: ""
        }

        var user = "";
        var categories;
        var TOOLTIPDELAY = 500;                                                                                    // Delay before showing tooltip when hovering
        var connection = "local";
        var locale;
        var netName = "";
        var mode = "Dashboard";
        var modalFunction;                                                                                          // Object to track modal callback

        //localStorage.setItem("serverName", serverName);
        var iFrame = document.getElementById("iFrame");
        if (debugURL !== "") iFrame.src = "dashboard.html" + debugURL;                                              // Reload dashboard from server not cache if debugging (will make the screen glitch on load)

        window.addEventListener("resize", function (e) {
            iFrame.height = window.innerHeight - 110;                                                               // compensate for bootstrap navbar
            deviceWidth = screen.availWidth;
        });

        document.addEventListener("keydown", function (e) {
            if (typeof iFrame.contentWindow.keyPress === "function") iFrame.contentWindow.keyPress(e);              // pass keystrokes to iframe for processing if focus is on parent
        }, true);

        iFrame.height = window.innerHeight - 110;                                                                   // compensate for bootstrap navbar
        document.getElementById("versionTxt").innerText = "Version: " + document.getElementById("version").content;

        // Activate the main framework functions and adjust button visibility
        function adjustNavBar(button) {
            if (button !== mode) {                                                                                  // Don't adjust mode if the active button is pressed
                if (clientName !== "" && netState.indexOf("session") !== -1) {
                    if (iFrame.contentWindow.g.dirty === true) {
                        modalDialog("dirty", "Unsaved Changes", "Unsaved changes have not been saved and will be lost if you continue", "OK", button);
                    } else {
                        if (button === "Design") {
                            document.getElementById("designButton").className = "active";
                            document.getElementById("toolboxDropdown").style.setProperty("display", "inline");
                            if (iFrame.src.toString().toLowerCase().indexOf("dashboard") == -1) {
                                iFrame.setAttribute("src", "dashboard.html" + debugURL);                                // Design uses dashboard, reload it if not active
                                setTimeout(startMQTTSess, 100);                                                         // Give dashboard a change to load
                            } else {
                                iFrame.contentWindow.setDesign();
                            }
                        } else {
                            iFrame.setAttribute("src", button + ".html" + debugURL);
                            document.getElementById("toolboxDropdown").style.setProperty("display", "none");
                            document.getElementById("designButton").className = "pointer";
                        }
                        if (button === "Dashboard") {
                            setTimeout(startMQTTSess, 100);
                            document.getElementById("dashButton").className = "active";
                        } else {
                            if (mode === "Dashboard") iFrame.contentWindow.endWidgetSess();
                            document.getElementById("dashButton").className = "pointer";
                        }
                        if (button === "Queries") document.getElementById("queryButton").className = "active";
                        else document.getElementById("queryButton").className = "pointer";
                        if (button === "Settings") document.getElementById("settingsButton").className = "active";
                        else document.getElementById("settingsButton").className = "pointer";
                        if (button === "Help") document.getElementById("helpButton").className = "active";
                        else document.getElementById("helpButton").className = "pointer";
                        status(button + " Mode");
                        mode = button;
                    }
                }
            }
        }

        // Login
        function login() {
            if (netState != "starting") {
                modalDialog("logon", "User Login", "Enter username and password to login", "Login");
            } else {
                alert("Unable to connect to server. Try later.");
            }
        }

        //TODO: Better document how modals work
        // show modal dialog. Global modalFunction used to define callback routine
        function modalDialog(type, title, text, button, callback, param) {
            if (text === undefined) text = "";
            if (type === "logon") {
                document.getElementById("formLogin").style.setProperty("display", "inline");
                document.getElementById("formInput").style.setProperty("display", "none");
            }
            if (type === "input") {
                document.getElementById("formInput").style.setProperty("display", "inline");
                document.getElementById("formLogin").style.setProperty("display", "none");
            }
            modalFunction = { type: type, func: callback, param: param }
            document.getElementById("modalTitle").innerHTML = title;
            document.getElementById("modalText").innerHTML = text;
            document.getElementById("cancelButton").style.setProperty("display", "none");
            if (button) {                                                                           // only show cancel button if no button text is specified (OK by default). If text = continue then don't show cancel
                document.getElementById("modalButton").innerHTML = button;
                if (button.toLowerCase() != "continue") document.getElementById("cancelButton").style.setProperty("display", "inline");
            } else {
                document.getElementById("modalButton").innerHTML = "OK";
            }
            $("#myModal").modal()
        }

        // callback from modal form CANCEL button, clear status.
        function modalCancel() {
            status("Cancelled");
        }

        // callback from modal form OK button push.
        function modalOK() {
            var param = document.getElementById("modalInput").value;
            $("#myModal").modal("hide");
            if (param === "") param = modalFunction.param;
            switch (modalFunction.type) {
                case "logon":
                    user = "local_machine"
                    var password = "xx"
                    //send("NETWORK", "LOGIN", password)        // Establish a user session
                    user = "";
                    break;
                case "dirty":
                    iFrame.contentWindow.g.dirty = false;
                    adjustNavBar(modalFunction.func);
                    break;
                default:
                    if (window[modalFunction.func] === undefined) {
                        iFrame.contentWindow.modalCallback(modalFunction.func, param);       // pass to iframe modal callback
                    } else {
                        window[modalFunction.func](param);
                    }
                    break;

            }
            document.getElementById("modalInput").value = "";
        }

        // Display status message in status bottom bar
        function status(message) {
            document.getElementById("serverStatus").innerText = message
        }

        // enable bootstrap tooltips
        function enableTooltip() {
            $(".tip").tooltip({ delay: { show: TOOLTIPDELAY } });
        }

        // clear cache (called by uwpbrowser exe)
        function clearCache() {
            location.reload(true);
            status("Cache reloaded.")
        }

        // Client impersonation
        function reload(path) {
            window.location.href = path;                                                            // reload with path/querystring
        }

        // Performance profile string
        function profiler(text) {
            console.timeEnd("profile");
        }

        /////////////////////////////////////////// MQTT Client (v3.11 support only)

        var CTRLCODE = {
            CONNECT: 0x10,
            CONNACK: 0x20,
            PUBLISH: 0x30,
            PUBACK: 0x40,
            PUBREC: 0x50,
            PUBREL: 0x62,
            PUBCOMP: 0x70,
            SUBSCRIBE: 0x82,
            SUBACK: 0x90,
            UNSUBSCRIBE: 0xA2,
            UNSUBACK: 0xB0,
            pingSend: 0xC0,
            PINGRESP: 0xD0,
            DISCONNECT: 0xE0
        };

        var CONNACKCODE = {
            1: "Connection Refused: incorrect protocol version",
            2: "Connection Refused: identifier rejected",
            3: "Connection Refused: service unavailable",
            4: "Connection Refused: bad user name or password",
            5: "Connection Refused: not authorized"
        };

        function startMQTTSess() {
            MQTTConnect("localhost", g.net.WSPORT, clientName, "FRED", "NIRKS", g.net.KEEPALIVE)
        }

        function MQTTConnect(serverName, portNum, clientName, username, password, keepAlive) {
            // Connflags - Bit 0 reserved: 0, bit 1 Clean session: 1 (purge old state), bit 2 Will flag: 0 (no will), bit 3/4 Will QoS flag: 0 (no QoS), bit 5 Will retain: 0 (no retain), bit 6 Username: 1 (use username), bit 7 Password: 1 (use password)
            g.net.connPayload = [0, 4, 77, 81, 84, 84, 4, 1 << 7 | 1 << 6 | 0 << 5 | 0 << 4 | 0 << 3 | 0 << 2 | 1 << 1, 0, keepAlive];     // variable header. Connect packet assume less 128 bytes. protocol level 4 MQTT v3.11
            g.net.connPayload = g.net.connPayload.concat(encodeUTF8(clientName), encodeUTF8(username), encodeUTF8(password));

            try {
                g.net.wsMQTT = new WebSocket(protocol + "//" + serverName + ":" + portNum, "MQTT");
                g.net.wsMQTT.binaryType = "arraybuffer";
            } catch (ex) {
                MQTTSessEnd("System error starting network. Error: " + ex.toString());
            }

            g.net.wsMQTT.onopen = function () {
                MQTTSend(CTRLCODE.CONNECT, g.net.connPayload);
                g.netState = "WSsession"
                MQTTSubscribe(["+/SYSTEM/WEBCLIENT/" + clientName]);              // Subscribe to the client channel for this client
            }

            g.net.wsMQTT.onmessage = function (evt) {
                MQTTRecvMsg(evt);
            }

            g.net.wsMQTT.onerror = function (evt) {
                g.net.netState = "error"
                MQTTSessEnd("Network error detected. Session with server closed.");
            }

            g.net.wsMQTT.onclose = function (evt) {
                g.net.netState = "disconnected"
                MQTTSessEnd("Network session with server closed.");
            }
        }

        // process MQTT messages received
        function MQTTRecvMsg(evt) {
            var recvArr = new Uint8Array(evt.data);

            clearTimeout(g.net.msgTimer);

            var recvLen = 0;
            var lenMult = 1;
            for (var i = 0; i < recvArr.length; i++) {                                 // Decode MQTT remaining length buffer
                recvLen += (recvArr[i + 1] & 0x7F) * lenMult;
                lenMult *= 0x80;
                if (recvArr[i] < 0x80)
                    break;          // No more bytes to encode length if value < 128
                if (i == 3) {
                    MQTTSessEnd("Incorrect MQTT message length received, length encoded as > 256Mb.");
                }
            }
            if (recvArr.length !== (recvLen + 2)) {
                MQTTSessEnd("Incorrect MQTT message length received, got " + recvArr.length + " but expecting " + (recvArr[1] + 2) + " bytes.");
            }

            switch (recvArr[0] & 0xF0) {
                case CTRLCODE.CONNACK:
                    g.net.sessPresent = recvArr[2];

                    switch (recvArr[3]) {                                                       // Connect return code
                        case 0:
                            g.netState = "MQTTsession";                                         // MQTT Session active
                            MQTTPublish("+/XXXX/CCCCC", "1234567890")
                            status("Connected with server " + serverName);
                            break;
                        case 1:                                                             // Server couldn't establish the session
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        default:
                            MQTTSessEnd(CONNACKCODE[recvArr[3]] + " from server " + serverName);            // Connect status code message
                    }
                    break;

                case CTRLCODE.PINGRESP:                                                 // No need to handle, message response timer handles any timeout
                    break;

                case CTRLCODE.PUBLISH:
                    recvPublish(recvArr, recvLen);
                    break;

                case CTRLCODE.PUBACK:
                case CTRLCODE.PUBREL:
                case CTRLCODE.PUBREC:
                case CTRLCODE.PUBCOMP:
                    status("Not supporting publish QoS > 0");
                    break;

                case CTRLCODE.SUBACK:
                    // TODO: CHeck for packetID
                    break;

                case CTRLCODE.UNSUBACK:
                    // CHeck for packetID
                    break;

                default:
                    MQTTSessEnd("Invalid MQTT message received - code: " + recvArr[0]);
            }
        }

        // Extract topic and data from publish packet
        function recvPublish(recvArr, payLen) {
            var arrPtr = 0;
            var packetID;
            var dup = recvArr[arrPtr] & 0x08;                                                               // Duplicate publish, not used
            var QoS = (recvArr[arrPtr] & 0x06) >> 1;                                                        // QoS not used
            var retain = recvArr[arrPtr++] & 0x01;                                                          // Retain set by server if the result of a new subscription sending stored state
            var topicLen = recvArr[++arrPtr] * 0xFF + recvArr[++arrPtr];
            var topic = decodeUTF8(recvArr, ++arrPtr, topicLen);
            if (g.net.QoS !== 0)
                packetID = recvArr[++arrPtr] * 0xFF + recvArr[++arrPtr];                   // Not used
            var data = decodeUTF8(recvArr, arrPtr + topicLen, recvArr.length - arrPtr - topicLen);
            procPublish(topic, data, retain);
        }

        function MQTTPublish(topic, data) {
            var payload = encodeUTF8(topic);
            if (g.net.QoS !== 0)
                payload.push(MQTTGetPacketID());                                                     // Add packetID for QoS > 0
            payload = payload.concat(encodeUTF8(data).splice(2));                                               // Convert UTF strings (remove MSB/LSB from routine by splice)
            MQTTSend(CTRLCODE.PUBLISH | (g.net.QoS << 1) | (g.net.retain ? 0x01 : 0x00), payload);                      // Not supporting DUP
        }

        // Subscribe to array of [topic]
        function MQTTSubscribe(topicArr) {
            if (!Array.isArray(topicArr) || topicArr.length == 0)
                return false;
            var payload = MQTTGetPacketID();
            for (var item in topicArr) {
                payload = payload.concat(encodeUTF8(topicArr[item]));
                payload.push(g.net.QoS);
            }
            return MQTTSend(CTRLCODE.SUBSCRIBE, payload);
        }

        // Remove subscription(s) array [topic]
        function MQTTUnsubscribe(topicArr) {
            if (!Array.isArray(topicArr) || topicArr.length == 0)
                return false;
            var payload = MQTTGetPacketID();
            for (var item in topicArr) {
                payload = payload.concat(encodeUTF8(topicArr[item]));
            }
            return MQTTSend(CTRLCODE.UNSUBSCRIBE, payload);
        }

        // Send a ping with period set by keepalive, only if no messages sent within ping period, message timeout timer will capture any net/server problems
        function pingSend() {
            MQTTSend(CTRLCODE.pingSend, new Array());
        }

        // Handle message response timeouts
        function responseTimeout() {
            MQTTSessEnd("Timed out waiting for Server.");
        }

        // Orderly shutdown of session layers
        function MQTTSessEnd(errStr) {
            if (errStr !== "")
                status("Closing server session with status: " + errStr)
            switch (g.net.netState) {
                case "MQTTsesson":
                    MQTTSend(CTRLCODE.DISCONNECT, new Array());                         // Disconnect MQTT session on server first
                case "WSsession":
                case "error":
                    g.net.wsMQTT.close;
            }
            clearInterval(g.net.keepAliveInterval);
            clearTimeout(g.net.msgTimer);
            setTimeout(startMQTTSess, 1000);                         // Try connecting again
        }

        // PacketID is unique 16 bit returned in MSB/LSB array
        function MQTTGetPacketID() {
            var packetID = [g.net.packetID >> 8, g.net.packetID & 0xFF];
            g.net.packetID++;
            if (g.net.packetID > 65535)
                packetID = 0;
            return packetID;
        }

        // Send MQTT payload adding the fixed header
        function MQTTSend(msgType, payload) {
            if (!Array.isArray(payload)) return false;
            var encLen;
            var remLen = payload.length;
            var lenArr = [];
            do {                                                                                // Encode MQTT remaining length
                encLen = remLen % 0x80;
                remLen = (remLen / 0x80) & 0xFF;
                if (remLen > 0)
                    encLen = encLen | 0x80;                                         // if there are more data to encode, set the top bit of this byte
                lenArr[lenArr.length] = encLen;
            } while (remLen > 0);

            payload = lenArr.concat(payload);
            payload.unshift(msgType);

            try {
                g.net.wsMQTT.send(new Uint8Array(payload));
            } catch (ex) {
                MQTTSessEnd("System error sending to server: " + ex.toString());
                return false;
            }
            clearTimeout(g.net.msgTimer);                                                  // set timeout waiting for server response (none for disconnect)
            clearInterval(g.net.keepAliveInterval);
            if (msgType !== CTRLCODE.DISCONNECT) {
                g.net.msgTimer = setTimeout(responseTimeout, g.net.responseTimeout * 1000);
                if (g.net.KEEPALIVE > 0)
                    g.net.keepAliveInterval = setInterval(pingSend, g.net.KEEPALIVE * 1000);                                  // reset Ping keepalive period timer
            }
            return true;
        }

        // Payload array for MQTT UTF8 strings, [MSB, LSB length, expand UTF-8 to binary]
        function encodeUTF8(str) {
            var UTFArr = [];
            for (var i = 0; i < str.length; i++) {
                var charCode = str.charCodeAt(i);
                if (0xD800 <= charCode && charCode <= 0xDBFF) {                                     // Surrogate pair check
                    lowCharCode = input.charCodeAt(++i);
                    if (isNaN(lowCharCode)) {
                        status("Bad UTF-8 string provided");
                        return [];
                    }
                    charCode = ((charCode - 0xD800) << 10) + (lowCharCode - 0xDC00) + 0x10000;
                }
                if (charCode <= 0x7F) {
                    UTFArr[UTFArr.length] = charCode;
                } else if (charCode <= 0x7FF) {
                    UTFArr[UTFArr.length] = charCode >> 6 & 0x1F | 0xC0;
                    UTFArr[UTFArr.length] = charCode & 0x3F | 0x80;
                } else if (charCode <= 0xFFFF) {
                    UTFArr[UTFArr.length] = charCode >> 12 & 0x0F | 0xE0;
                    UTFArr[UTFArr.length] = charCode >> 6 & 0x3F | 0x80;
                    UTFArr[UTFArr.length] = charCode & 0x3F | 0x80;
                } else {
                    UTFArr[UTFArr.length] = charCode >> 18 & 0x07 | 0xF0;
                    UTFArr[UTFArr.length] = charCode >> 12 & 0x3F | 0x80;
                    UTFArr[UTFArr.length] = charCode >> 6 & 0x3F | 0x80;
                    UTFArr[UTFArr.length] = charCode & 0x3F | 0x80;
                }
            }
            UTFArr.unshift(UTFArr.length & 0xFF);
            UTFArr.unshift(UTFArr.length  >> 8);
            return UTFArr;
        }

        // Decode UTF8 string in publish message
        function decodeUTF8(input, offset, length) {
            var output = "";
            var utf16;
            var pos = offset;

            while (pos < offset + length) {
                var byte1 = input[pos++];
                if (byte1 < 128)
                    utf16 = byte1;
                else {
                    var byte2 = input[pos++] - 128;
                    if (byte2 < 0) {
                        status("Malformed UTF decoded byte 2: " + byte2.toString(16));
                        return "";
                    }
                    if (byte1 < 0xE0)             // 2 byte character
                        utf16 = 64 * (byte1 - 0xC0) + byte2;
                    else {
                        var byte3 = input[pos++] - 128;
                        if (byte3 < 0) {
                            status("Malformed UTF decoded byte 3: " + byte3.toString(16));
                            return "";
                        }
                        if (byte1 < 0xF0)        // 3 byte character
                            utf16 = 4096 * (byte1 - 0xE0) + 64 * byte2 + byte3;
                        else {
                            var byte4 = input[pos++] - 128;
                            if (byte4 < 0) {
                                status("Malformed UTF decoded byte 4: " + byte4.toString(16));
                                return "";
                            }
                            if (byte1 < 0xF8)        // 4 byte character
                                utf16 = 262144 * (byte1 - 0xF0) + 4096 * byte2 + 64 * byte3 + byte4;
                            else {
                                status("Not supporting UTF encoding > 4 bytes");                                                    // longer encodings are not supported
                                return "";
                            }
                        }
                    }
                }

                if (utf16 > 0xFFFF)   // 4 byte character - express as a surrogate pair
                {
                    utf16 -= 0x10000;
                    output += String.fromCharCode(0xD800 + (utf16 >> 10)); // lead character
                    utf16 = 0xDC00 + (utf16 & 0x3FF);  // trail character
                }
                output += String.fromCharCode(utf16);
            }
            return output;
        }

        //#region /////////////////////////////////////// Handle Server messages

        function procPublish(topic, data, retain) {
            status("received topic: " + topic + " Data: " + data);
        }

        //#region /////////////////////////////////////// Network

        function startNet() {
            try {
                //TODO: Use wss for secure websockets
                ws = new WebSocket(protocol + "//" + serverName + ":" + wsPort + "/HAclient");
            } catch (exception) {
                alert("ERROR: Cannot start web services, either due to a network error or using an older HTML5 incompatible browser")
            }
            try {
                ws.onopen = function () {
                    profiler("wsopen");
                    netState = "connected"
                    status("Connected to Server. Establishing session...")
                    send("NETWORK", "CONNECT", "");          // Establish initial generic machine session
                    user = "local_machine"
                    setTimeout(checkSession, 10000);        // If HA Server isn't responding, restart
                }

                ws.onmessage = function (evt) {
                    try {
                        var msg = JSON.parse(evt.data);
                    } catch (e) {
                        status("WARNING - Invalid message received from Server");
                        return;
                    }
                    //TODO: Check for relevant network number
                    switch (msg.Func) {
                        case func.response:
                            switch (msg.Category.toUpperCase()) {
                                case "SYSTEM":    // system
                                    switch (msg.ClassName.toUpperCase()) {
                                        case "MISC":
                                            switch (msg.Scope.toUpperCase()) {
                                                case "ALERT":                               // Server can create an alert window if needed (eg. server errors).
                                                    alert(msg.Data)
                                                    break;
                                                default:
                                            }
                                            break;
                                        case "SETTINGS":
                                            switch (msg.Scope.toUpperCase()) {
                                                case "GET:CATEGORIES()":
                                                    categories = JSON.parse(msg.Data);
                                                    send("WIDGETS", "CHANNELS", "")
                                                    break;
                                                default:
                                            }
                                            break;
                                        case "NETWORK":
                                            switch (msg.Instance.toUpperCase()) {
                                                case "SERVER":
                                                    switch (msg.Scope.toUpperCase()) {
                                                        case "CONNECT":             // user session connected
                                                            clientName = msg.Data.ClientName;
                                                            if (localStorage.getItem("clientName") != clientName && params[0].toLowerCase() != "clientname") localStorage.setItem("clientName", clientName);       // save clientName from server (local javascript can't get client name) but not if using another clientname (from the http query string)
                                                            netName = msg.Data.ServerName;
                                                            locale = msg.Data.Locale;
                                                            document.getElementById("headerTitle").innerHTML = "&nbsp;" + netName
                                                            netState = "localsession"
                                                            document.getElementById("displayUser").innerHTML = "<strong>" + clientName + "</strong>";
                                                            if (deviceWidth > 1024) {
                                                                document.getElementById("dashButton").style.setProperty("display", "inline");
                                                                document.getElementById("settingsButton").style.setProperty("display", "inline");
                                                                document.getElementById("designButton").style.setProperty("display", "inline");
                                                                document.getElementById("queryButton").style.setProperty("display", "inline");
                                                            }
                                                            document.getElementById("logonButton").style.setProperty("visibility", "visible");
                                                            status("Connected to server " + serverName + ".");
                                                            msg.ClassName = "INITLOAD";
                                                            profiler("HAClientiniload")
                                                            waitForIframe(msg)
                                                            break;
                                                        case "AUTHENTICATED":             // user session connected
                                                            user = msg.Data;
                                                            netState = "usersession"
                                                            document.getElementById("displayUser").innerHTML = "Welcome <strong>" + user + "</strong>";
                                                            status("Ready. Logged in as " + user);
                                                            break;
                                                        case "DISCONNECT":
                                                            netState = "disconnected";
                                                            clientName = "";
                                                            //iFrame.setAttribute("src", "")
                                                            document.getElementById("displayUser").innerHTML = "Please login first";
                                                            document.getElementById("dashButton").style.setProperty("display", "none");
                                                            document.getElementById("settingsButton").style.setProperty("display", "none");
                                                            document.getElementById("designButton").style.setProperty("display", "none");
                                                            document.getElementById("queryButton").style.setProperty("display", "none");
                                                            break;
                                                        default:
                                                    }
                                                    break;
                                                default:
                                            }
                                            break;
                                        default:
                                            waitForIframe(msg);
                                    }
                                    break;
                                default:
                            }
                            break;
                        case func.action:
                            break;
                        case func.event:
                            if (typeof iFrame.contentWindow.recvHost === "function") iFrame.contentWindow.recvHost(msg)                         // pass network events to widgets
                            break;
                        case func.error:
                            alert("Error received from Server: " + msg.Data)
                            break;
                        default:
                            alert("Do not understand Server message function: " + msg.Func)
                            break;
                    }
                }

                // Server usually responds before Iframe has loaded, so wait.
                function waitForIframe(msg) {
                    if (typeof iFrame.contentWindow.recvHost === "function") iFrame.contentWindow.recvHost(msg);
                    else setTimeout(waitForIframe, 5, msg);
                }

                ws.onerror = function (evt) {
                    status("Network Error was reported: " + evt.type);
                }

                ws.onclose = function (evt) {
                    adjustNavBar("Dashboard");                               // If re-establishing a broken connection, reset to dashboard.
                    if (netState === "starting") {
                        status("Cannot connect to the server. Please check server availability. Retrying...");
                    } else {
                        status("Server connection closed");
                        netState = "closed"
                    }
                    setTimeout(startNet, 500);
                }
            } catch (exception) {
                alert("General Network Error was reported: " + exception);
            }
        };

        function checkSession() {
            if (netState === "connected") ws.close();                                 // No session established after 3 seconds, close to restart
        }

        function send(className, scope, data) {
            try {
                templMsg.category = "SYSTEM";                               // General system message
                templMsg.func = func.action;                                // Raise user or system action
                templMsg.className = className;
                templMsg.instance = clientName;
                templMsg.scope = scope;
                templMsg.data = data;
                ws.send(buildJSON(templMsg))
            } catch (exception) {
                alert("Network Send Error was reported : " + exception);
            }
        }

        //TODO: Can consilidate with send
        function channelSend(fullChName, scope, data) {
            try {
                var channelInfo = fullChName.split("/")
                templMsg.category = channelInfo[0];                         // Channel category
                templMsg.func = func.event;                                 // Raise plugin event
                templMsg.className = channelInfo[1];
                templMsg.instance = channelInfo[2];
                templMsg.scope = scope;
                templMsg.data = data;
                ws.send(buildJSON(templMsg));                                // Send to Server
            } catch (exception) { alert("Network Send Error was reported : " + exception); }
        }

        // Structure the message based on event format
        function buildJSON(myMsg) {
            var myJSONObject = {
                "Client": clientName, "Func": myMsg.func, "Level": myMsg.level, "Network": myMsg.network, "Category": myMsg.category, "ClassName": myMsg.className, "Instance": myMsg.instance, "Scope": myMsg.scope, "Data": myMsg.data
            };
            var myJSON = JSON.stringify(myJSONObject);
            return myJSON;
        }

    </script>
    <script defer src="js/jquery-3.1.0.slim.min.js"></script>
    <script defer src="js/bootstrap.min.js"></script>
</body>
</html>
